
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model users
 * 
 */
export type users = {
  id_user: number
  cd_company: number
  ds_email: string
  ds_name: string
  ds_password: string
  id_manager: boolean
  id_operational: boolean
  id_operator: boolean
}

/**
 * Model company
 * 
 */
export type company = {
  id_company: number
  ds_cnpj: string
  ds_name: string
}

/**
 * Model location
 * 
 */
export type location = {
  id_location: number
  ds_location: string
  cd_company: number
}

/**
 * Model move_status
 * 
 */
export type move_status = {
  id_status: number
  ds_status: string
}

/**
 * Model client
 * 
 */
export type client = {
  id_client: number
  ds_name: string
  ds_cpf: string
  cd_company: number
}

/**
 * Model mariner
 * 
 */
export type mariner = {
  id_mariner: number
  ds_name: string
  ds_cpf: string
  cd_company: number
}

/**
 * Model ship
 * 
 */
export type ship = {
  id_ship: number
  ds_ship: string
  cd_company: number
}

/**
 * Model ship_mariner
 * 
 */
export type ship_mariner = {
  cd_ship: number
  cd_mariner: number
  id_cliente_mariner: number
}

/**
 * Model ship_client
 * 
 */
export type ship_client = {
  cd_ship: number
  cd_client: number
  id_cliente_mariner: number
}

/**
 * Model movimentation
 * 
 */
export type movimentation = {
  id_movimentation: number
  cd_company: number
  dt_finished: Date | null
  dt_opned: Date
  id_finished: boolean
  cd_move_status: number
  cd_nav_plan: number | null
}

/**
 * Model navagation_plan
 * 
 */
export type navagation_plan = {
  qt_crew: number
  qt_passengers: number
  dt_departure: Date
  dt_arrival: Date | null
  ds_observation: string | null
  cd_destiny: number
  cd_user: number
  cd_company: number
  cd_move_status: number
  id_nav_plan: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.companyDelegate<GlobalReject>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<GlobalReject>;

  /**
   * `prisma.move_status`: Exposes CRUD operations for the **move_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Move_statuses
    * const move_statuses = await prisma.move_status.findMany()
    * ```
    */
  get move_status(): Prisma.move_statusDelegate<GlobalReject>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.clientDelegate<GlobalReject>;

  /**
   * `prisma.mariner`: Exposes CRUD operations for the **mariner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mariners
    * const mariners = await prisma.mariner.findMany()
    * ```
    */
  get mariner(): Prisma.marinerDelegate<GlobalReject>;

  /**
   * `prisma.ship`: Exposes CRUD operations for the **ship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ships
    * const ships = await prisma.ship.findMany()
    * ```
    */
  get ship(): Prisma.shipDelegate<GlobalReject>;

  /**
   * `prisma.ship_mariner`: Exposes CRUD operations for the **ship_mariner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ship_mariners
    * const ship_mariners = await prisma.ship_mariner.findMany()
    * ```
    */
  get ship_mariner(): Prisma.ship_marinerDelegate<GlobalReject>;

  /**
   * `prisma.ship_client`: Exposes CRUD operations for the **ship_client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ship_clients
    * const ship_clients = await prisma.ship_client.findMany()
    * ```
    */
  get ship_client(): Prisma.ship_clientDelegate<GlobalReject>;

  /**
   * `prisma.movimentation`: Exposes CRUD operations for the **movimentation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movimentations
    * const movimentations = await prisma.movimentation.findMany()
    * ```
    */
  get movimentation(): Prisma.movimentationDelegate<GlobalReject>;

  /**
   * `prisma.navagation_plan`: Exposes CRUD operations for the **navagation_plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Navagation_plans
    * const navagation_plans = await prisma.navagation_plan.findMany()
    * ```
    */
  get navagation_plan(): Prisma.navagation_planDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Prisma Client JS version: 3.15.2
   * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    users: 'users',
    company: 'company',
    location: 'location',
    move_status: 'move_status',
    client: 'client',
    mariner: 'mariner',
    ship: 'ship',
    ship_mariner: 'ship_mariner',
    ship_client: 'ship_client',
    movimentation: 'movimentation',
    navagation_plan: 'navagation_plan'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    navagation_plan: number
  }

  export type UsersCountOutputTypeSelect = {
    navagation_plan?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type CompanyCountOutputType
   */


  export type CompanyCountOutputType = {
    client: number
    location: number
    mariner: number
    movimentation: number
    navagation_plan: number
    ship: number
    users: number
  }

  export type CompanyCountOutputTypeSelect = {
    client?: boolean
    location?: boolean
    mariner?: boolean
    movimentation?: boolean
    navagation_plan?: boolean
    ship?: boolean
    users?: boolean
  }

  export type CompanyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CompanyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CompanyCountOutputType
    : S extends undefined
    ? never
    : S extends CompanyCountOutputTypeArgs
    ?'include' extends U
    ? CompanyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CompanyCountOutputType ? CompanyCountOutputType[P] : never
  } 
    : CompanyCountOutputType
  : CompanyCountOutputType




  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     * 
    **/
    select?: CompanyCountOutputTypeSelect | null
  }



  /**
   * Count Type LocationCountOutputType
   */


  export type LocationCountOutputType = {
    navagation_plan: number
  }

  export type LocationCountOutputTypeSelect = {
    navagation_plan?: boolean
  }

  export type LocationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LocationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LocationCountOutputType
    : S extends undefined
    ? never
    : S extends LocationCountOutputTypeArgs
    ?'include' extends U
    ? LocationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LocationCountOutputType ? LocationCountOutputType[P] : never
  } 
    : LocationCountOutputType
  : LocationCountOutputType




  // Custom InputTypes

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     * 
    **/
    select?: LocationCountOutputTypeSelect | null
  }



  /**
   * Count Type Move_statusCountOutputType
   */


  export type Move_statusCountOutputType = {
    movimentation: number
    navagation_plan: number
  }

  export type Move_statusCountOutputTypeSelect = {
    movimentation?: boolean
    navagation_plan?: boolean
  }

  export type Move_statusCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Move_statusCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Move_statusCountOutputType
    : S extends undefined
    ? never
    : S extends Move_statusCountOutputTypeArgs
    ?'include' extends U
    ? Move_statusCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Move_statusCountOutputType ? Move_statusCountOutputType[P] : never
  } 
    : Move_statusCountOutputType
  : Move_statusCountOutputType




  // Custom InputTypes

  /**
   * Move_statusCountOutputType without action
   */
  export type Move_statusCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Move_statusCountOutputType
     * 
    **/
    select?: Move_statusCountOutputTypeSelect | null
  }



  /**
   * Count Type ClientCountOutputType
   */


  export type ClientCountOutputType = {
    ship_client: number
  }

  export type ClientCountOutputTypeSelect = {
    ship_client?: boolean
  }

  export type ClientCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ClientCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ClientCountOutputType
    : S extends undefined
    ? never
    : S extends ClientCountOutputTypeArgs
    ?'include' extends U
    ? ClientCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ClientCountOutputType ? ClientCountOutputType[P] : never
  } 
    : ClientCountOutputType
  : ClientCountOutputType




  // Custom InputTypes

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     * 
    **/
    select?: ClientCountOutputTypeSelect | null
  }



  /**
   * Count Type MarinerCountOutputType
   */


  export type MarinerCountOutputType = {
    ship_mariner: number
  }

  export type MarinerCountOutputTypeSelect = {
    ship_mariner?: boolean
  }

  export type MarinerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MarinerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MarinerCountOutputType
    : S extends undefined
    ? never
    : S extends MarinerCountOutputTypeArgs
    ?'include' extends U
    ? MarinerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MarinerCountOutputType ? MarinerCountOutputType[P] : never
  } 
    : MarinerCountOutputType
  : MarinerCountOutputType




  // Custom InputTypes

  /**
   * MarinerCountOutputType without action
   */
  export type MarinerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MarinerCountOutputType
     * 
    **/
    select?: MarinerCountOutputTypeSelect | null
  }



  /**
   * Count Type ShipCountOutputType
   */


  export type ShipCountOutputType = {
    ship_client: number
    ship_mariner: number
  }

  export type ShipCountOutputTypeSelect = {
    ship_client?: boolean
    ship_mariner?: boolean
  }

  export type ShipCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShipCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShipCountOutputType
    : S extends undefined
    ? never
    : S extends ShipCountOutputTypeArgs
    ?'include' extends U
    ? ShipCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ShipCountOutputType ? ShipCountOutputType[P] : never
  } 
    : ShipCountOutputType
  : ShipCountOutputType




  // Custom InputTypes

  /**
   * ShipCountOutputType without action
   */
  export type ShipCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShipCountOutputType
     * 
    **/
    select?: ShipCountOutputTypeSelect | null
  }



  /**
   * Count Type Navagation_planCountOutputType
   */


  export type Navagation_planCountOutputType = {
    movimentation: number
  }

  export type Navagation_planCountOutputTypeSelect = {
    movimentation?: boolean
  }

  export type Navagation_planCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Navagation_planCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Navagation_planCountOutputType
    : S extends undefined
    ? never
    : S extends Navagation_planCountOutputTypeArgs
    ?'include' extends U
    ? Navagation_planCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Navagation_planCountOutputType ? Navagation_planCountOutputType[P] : never
  } 
    : Navagation_planCountOutputType
  : Navagation_planCountOutputType




  // Custom InputTypes

  /**
   * Navagation_planCountOutputType without action
   */
  export type Navagation_planCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Navagation_planCountOutputType
     * 
    **/
    select?: Navagation_planCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id_user: number | null
    cd_company: number | null
  }

  export type UsersSumAggregateOutputType = {
    id_user: number | null
    cd_company: number | null
  }

  export type UsersMinAggregateOutputType = {
    id_user: number | null
    cd_company: number | null
    ds_email: string | null
    ds_name: string | null
    ds_password: string | null
    id_manager: boolean | null
    id_operational: boolean | null
    id_operator: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id_user: number | null
    cd_company: number | null
    ds_email: string | null
    ds_name: string | null
    ds_password: string | null
    id_manager: boolean | null
    id_operational: boolean | null
    id_operator: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id_user: number
    cd_company: number
    ds_email: number
    ds_name: number
    ds_password: number
    id_manager: number
    id_operational: number
    id_operator: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id_user?: true
    cd_company?: true
  }

  export type UsersSumAggregateInputType = {
    id_user?: true
    cd_company?: true
  }

  export type UsersMinAggregateInputType = {
    id_user?: true
    cd_company?: true
    ds_email?: true
    ds_name?: true
    ds_password?: true
    id_manager?: true
    id_operational?: true
    id_operator?: true
  }

  export type UsersMaxAggregateInputType = {
    id_user?: true
    cd_company?: true
    ds_email?: true
    ds_name?: true
    ds_password?: true
    id_manager?: true
    id_operational?: true
    id_operator?: true
  }

  export type UsersCountAggregateInputType = {
    id_user?: true
    cd_company?: true
    ds_email?: true
    ds_name?: true
    ds_password?: true
    id_manager?: true
    id_operational?: true
    id_operator?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id_user: number
    cd_company: number
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager: boolean
    id_operational: boolean
    id_operator: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id_user?: boolean
    cd_company?: boolean
    ds_email?: boolean
    ds_name?: boolean
    ds_password?: boolean
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
    Company?: boolean | companyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersInclude = {
    Company?: boolean | companyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Company' ? companyGetPayload<S['include'][P]> :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Company' ? companyGetPayload<S['select'][P]> :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id_user`
     * const usersWithId_userOnly = await prisma.users.findMany({ select: { id_user: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>;

    navagation_plan<T extends navagation_planFindManyArgs = {}>(args?: Subset<T, navagation_planFindManyArgs>): CheckSelect<T, PrismaPromise<Array<navagation_plan>>, PrismaPromise<Array<navagation_planGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Throw an Error if a users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Throw an Error if a users can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     * 
    **/
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     * 
    **/
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     * 
    **/
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     * 
    **/
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     * 
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     * 
    **/
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
  }



  /**
   * Model company
   */


  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id_company: number | null
  }

  export type CompanySumAggregateOutputType = {
    id_company: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id_company: number | null
    ds_cnpj: string | null
    ds_name: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id_company: number | null
    ds_cnpj: string | null
    ds_name: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id_company: number
    ds_cnpj: number
    ds_name: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id_company?: true
  }

  export type CompanySumAggregateInputType = {
    id_company?: true
  }

  export type CompanyMinAggregateInputType = {
    id_company?: true
    ds_cnpj?: true
    ds_name?: true
  }

  export type CompanyMaxAggregateInputType = {
    id_company?: true
    ds_cnpj?: true
    ds_name?: true
  }

  export type CompanyCountAggregateInputType = {
    id_company?: true
    ds_cnpj?: true
    ds_name?: true
    _all?: true
  }

  export type CompanyAggregateArgs = {
    /**
     * Filter which company to aggregate.
     * 
    **/
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     * 
    **/
    orderBy?: Enumerable<companyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs = {
    where?: companyWhereInput
    orderBy?: Enumerable<companyOrderByWithAggregationInput>
    by: Array<CompanyScalarFieldEnum>
    having?: companyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }


  export type CompanyGroupByOutputType = {
    id_company: number
    ds_cnpj: string
    ds_name: string
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type companySelect = {
    id_company?: boolean
    ds_cnpj?: boolean
    ds_name?: boolean
    client?: boolean | clientFindManyArgs
    location?: boolean | locationFindManyArgs
    mariner?: boolean | marinerFindManyArgs
    movimentation?: boolean | movimentationFindManyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    ship?: boolean | shipFindManyArgs
    users?: boolean | usersFindManyArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }

  export type companyInclude = {
    client?: boolean | clientFindManyArgs
    location?: boolean | locationFindManyArgs
    mariner?: boolean | marinerFindManyArgs
    movimentation?: boolean | movimentationFindManyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    ship?: boolean | shipFindManyArgs
    users?: boolean | usersFindManyArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }

  export type companyGetPayload<
    S extends boolean | null | undefined | companyArgs,
    U = keyof S
      > = S extends true
        ? company
    : S extends undefined
    ? never
    : S extends companyArgs | companyFindManyArgs
    ?'include' extends U
    ? company  & {
    [P in TrueKeys<S['include']>]:
        P extends 'client' ? Array < clientGetPayload<S['include'][P]>>  :
        P extends 'location' ? Array < locationGetPayload<S['include'][P]>>  :
        P extends 'mariner' ? Array < marinerGetPayload<S['include'][P]>>  :
        P extends 'movimentation' ? Array < movimentationGetPayload<S['include'][P]>>  :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['include'][P]>>  :
        P extends 'ship' ? Array < shipGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'client' ? Array < clientGetPayload<S['select'][P]>>  :
        P extends 'location' ? Array < locationGetPayload<S['select'][P]>>  :
        P extends 'mariner' ? Array < marinerGetPayload<S['select'][P]>>  :
        P extends 'movimentation' ? Array < movimentationGetPayload<S['select'][P]>>  :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['select'][P]>>  :
        P extends 'ship' ? Array < shipGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof company ? company[P] : never
  } 
    : company
  : company


  type companyCountArgs = Merge<
    Omit<companyFindManyArgs, 'select' | 'include'> & {
      select?: CompanyCountAggregateInputType | true
    }
  >

  export interface companyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Company that matches the filter.
     * @param {companyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'company'> extends True ? CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>> : CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'company'> extends True ? CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>> : CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id_company`
     * const companyWithId_companyOnly = await prisma.company.findMany({ select: { id_company: true } })
     * 
    **/
    findMany<T extends companyFindManyArgs>(
      args?: SelectSubset<T, companyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<company>>, PrismaPromise<Array<companyGetPayload<T>>>>

    /**
     * Create a Company.
     * @param {companyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends companyCreateArgs>(
      args: SelectSubset<T, companyCreateArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>

    /**
     * Create many Companies.
     *     @param {companyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companyCreateManyArgs>(
      args?: SelectSubset<T, companyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {companyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends companyDeleteArgs>(
      args: SelectSubset<T, companyDeleteArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>

    /**
     * Update one Company.
     * @param {companyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companyUpdateArgs>(
      args: SelectSubset<T, companyUpdateArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>

    /**
     * Delete zero or more Companies.
     * @param {companyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companyDeleteManyArgs>(
      args?: SelectSubset<T, companyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companyUpdateManyArgs>(
      args: SelectSubset<T, companyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {companyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends companyUpsertArgs>(
      args: SelectSubset<T, companyUpsertArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companyCountArgs>(
      args?: Subset<T, companyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    client<T extends clientFindManyArgs = {}>(args?: Subset<T, clientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<client>>, PrismaPromise<Array<clientGetPayload<T>>>>;

    location<T extends locationFindManyArgs = {}>(args?: Subset<T, locationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<location>>, PrismaPromise<Array<locationGetPayload<T>>>>;

    mariner<T extends marinerFindManyArgs = {}>(args?: Subset<T, marinerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<mariner>>, PrismaPromise<Array<marinerGetPayload<T>>>>;

    movimentation<T extends movimentationFindManyArgs = {}>(args?: Subset<T, movimentationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<movimentation>>, PrismaPromise<Array<movimentationGetPayload<T>>>>;

    navagation_plan<T extends navagation_planFindManyArgs = {}>(args?: Subset<T, navagation_planFindManyArgs>): CheckSelect<T, PrismaPromise<Array<navagation_plan>>, PrismaPromise<Array<navagation_planGetPayload<T>>>>;

    ship<T extends shipFindManyArgs = {}>(args?: Subset<T, shipFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ship>>, PrismaPromise<Array<shipGetPayload<T>>>>;

    users<T extends usersFindManyArgs = {}>(args?: Subset<T, usersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * company findUnique
   */
  export type companyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
    /**
     * Throw an Error if a company can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company to fetch.
     * 
    **/
    where: companyWhereUniqueInput
  }


  /**
   * company findFirst
   */
  export type companyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
    /**
     * Throw an Error if a company can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company to fetch.
     * 
    **/
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     * 
    **/
    orderBy?: Enumerable<companyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     * 
    **/
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     * 
    **/
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * company findMany
   */
  export type companyFindManyArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
    /**
     * Filter, which companies to fetch.
     * 
    **/
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     * 
    **/
    orderBy?: Enumerable<companyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     * 
    **/
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * company create
   */
  export type companyCreateArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
    /**
     * The data needed to create a company.
     * 
    **/
    data: XOR<companyCreateInput, companyUncheckedCreateInput>
  }


  /**
   * company createMany
   */
  export type companyCreateManyArgs = {
    /**
     * The data used to create many companies.
     * 
    **/
    data: Enumerable<companyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * company update
   */
  export type companyUpdateArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
    /**
     * The data needed to update a company.
     * 
    **/
    data: XOR<companyUpdateInput, companyUncheckedUpdateInput>
    /**
     * Choose, which company to update.
     * 
    **/
    where: companyWhereUniqueInput
  }


  /**
   * company updateMany
   */
  export type companyUpdateManyArgs = {
    /**
     * The data used to update companies.
     * 
    **/
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     * 
    **/
    where?: companyWhereInput
  }


  /**
   * company upsert
   */
  export type companyUpsertArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
    /**
     * The filter to search for the company to update in case it exists.
     * 
    **/
    where: companyWhereUniqueInput
    /**
     * In case the company found by the `where` argument doesn't exist, create a new company with this data.
     * 
    **/
    create: XOR<companyCreateInput, companyUncheckedCreateInput>
    /**
     * In case the company was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companyUpdateInput, companyUncheckedUpdateInput>
  }


  /**
   * company delete
   */
  export type companyDeleteArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
    /**
     * Filter which company to delete.
     * 
    **/
    where: companyWhereUniqueInput
  }


  /**
   * company deleteMany
   */
  export type companyDeleteManyArgs = {
    /**
     * Filter which companies to delete
     * 
    **/
    where?: companyWhereInput
  }


  /**
   * company without action
   */
  export type companyArgs = {
    /**
     * Select specific fields to fetch from the company
     * 
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companyInclude | null
  }



  /**
   * Model location
   */


  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id_location: number | null
    cd_company: number | null
  }

  export type LocationSumAggregateOutputType = {
    id_location: number | null
    cd_company: number | null
  }

  export type LocationMinAggregateOutputType = {
    id_location: number | null
    ds_location: string | null
    cd_company: number | null
  }

  export type LocationMaxAggregateOutputType = {
    id_location: number | null
    ds_location: string | null
    cd_company: number | null
  }

  export type LocationCountAggregateOutputType = {
    id_location: number
    ds_location: number
    cd_company: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id_location?: true
    cd_company?: true
  }

  export type LocationSumAggregateInputType = {
    id_location?: true
    cd_company?: true
  }

  export type LocationMinAggregateInputType = {
    id_location?: true
    ds_location?: true
    cd_company?: true
  }

  export type LocationMaxAggregateInputType = {
    id_location?: true
    ds_location?: true
    cd_company?: true
  }

  export type LocationCountAggregateInputType = {
    id_location?: true
    ds_location?: true
    cd_company?: true
    _all?: true
  }

  export type LocationAggregateArgs = {
    /**
     * Filter which location to aggregate.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs = {
    where?: locationWhereInput
    orderBy?: Enumerable<locationOrderByWithAggregationInput>
    by: Array<LocationScalarFieldEnum>
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }


  export type LocationGroupByOutputType = {
    id_location: number
    ds_location: string
    cd_company: number
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect = {
    id_location?: boolean
    ds_location?: boolean
    cd_company?: boolean
    Company?: boolean | companyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }

  export type locationInclude = {
    Company?: boolean | companyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }

  export type locationGetPayload<
    S extends boolean | null | undefined | locationArgs,
    U = keyof S
      > = S extends true
        ? location
    : S extends undefined
    ? never
    : S extends locationArgs | locationFindManyArgs
    ?'include' extends U
    ? location  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Company' ? companyGetPayload<S['include'][P]> :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['include'][P]>>  :
        P extends '_count' ? LocationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Company' ? companyGetPayload<S['select'][P]> :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['select'][P]>>  :
        P extends '_count' ? LocationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof location ? location[P] : never
  } 
    : location
  : location


  type locationCountArgs = Merge<
    Omit<locationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }
  >

  export interface locationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id_location`
     * const locationWithId_locationOnly = await prisma.location.findMany({ select: { id_location: true } })
     * 
    **/
    findMany<T extends locationFindManyArgs>(
      args?: SelectSubset<T, locationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<location>>, PrismaPromise<Array<locationGetPayload<T>>>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends locationCreateArgs>(
      args: SelectSubset<T, locationCreateArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Create many Locations.
     *     @param {locationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends locationCreateManyArgs>(
      args?: SelectSubset<T, locationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends locationDeleteArgs>(
      args: SelectSubset<T, locationDeleteArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationUpdateArgs>(
      args: SelectSubset<T, locationUpdateArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationDeleteManyArgs>(
      args?: SelectSubset<T, locationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationUpdateManyArgs>(
      args: SelectSubset<T, locationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends locationUpsertArgs>(
      args: SelectSubset<T, locationUpsertArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>;

    navagation_plan<T extends navagation_planFindManyArgs = {}>(args?: Subset<T, navagation_planFindManyArgs>): CheckSelect<T, PrismaPromise<Array<navagation_plan>>, PrismaPromise<Array<navagation_planGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * location findUnique
   */
  export type locationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Throw an Error if a location can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which location to fetch.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location findFirst
   */
  export type locationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Throw an Error if a location can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which location to fetch.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     * 
    **/
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location findMany
   */
  export type locationFindManyArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter, which locations to fetch.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location create
   */
  export type locationCreateArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * The data needed to create a location.
     * 
    **/
    data: XOR<locationCreateInput, locationUncheckedCreateInput>
  }


  /**
   * location createMany
   */
  export type locationCreateManyArgs = {
    /**
     * The data used to create many locations.
     * 
    **/
    data: Enumerable<locationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * location update
   */
  export type locationUpdateArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * The data needed to update a location.
     * 
    **/
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location updateMany
   */
  export type locationUpdateManyArgs = {
    /**
     * The data used to update locations.
     * 
    **/
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     * 
    **/
    where?: locationWhereInput
  }


  /**
   * location upsert
   */
  export type locationUpsertArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * The filter to search for the location to update in case it exists.
     * 
    **/
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
     * 
    **/
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }


  /**
   * location delete
   */
  export type locationDeleteArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter which location to delete.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs = {
    /**
     * Filter which locations to delete
     * 
    **/
    where?: locationWhereInput
  }


  /**
   * location without action
   */
  export type locationArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
  }



  /**
   * Model move_status
   */


  export type AggregateMove_status = {
    _count: Move_statusCountAggregateOutputType | null
    _avg: Move_statusAvgAggregateOutputType | null
    _sum: Move_statusSumAggregateOutputType | null
    _min: Move_statusMinAggregateOutputType | null
    _max: Move_statusMaxAggregateOutputType | null
  }

  export type Move_statusAvgAggregateOutputType = {
    id_status: number | null
  }

  export type Move_statusSumAggregateOutputType = {
    id_status: number | null
  }

  export type Move_statusMinAggregateOutputType = {
    id_status: number | null
    ds_status: string | null
  }

  export type Move_statusMaxAggregateOutputType = {
    id_status: number | null
    ds_status: string | null
  }

  export type Move_statusCountAggregateOutputType = {
    id_status: number
    ds_status: number
    _all: number
  }


  export type Move_statusAvgAggregateInputType = {
    id_status?: true
  }

  export type Move_statusSumAggregateInputType = {
    id_status?: true
  }

  export type Move_statusMinAggregateInputType = {
    id_status?: true
    ds_status?: true
  }

  export type Move_statusMaxAggregateInputType = {
    id_status?: true
    ds_status?: true
  }

  export type Move_statusCountAggregateInputType = {
    id_status?: true
    ds_status?: true
    _all?: true
  }

  export type Move_statusAggregateArgs = {
    /**
     * Filter which move_status to aggregate.
     * 
    **/
    where?: move_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of move_statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<move_statusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: move_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` move_statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` move_statuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned move_statuses
    **/
    _count?: true | Move_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Move_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Move_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Move_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Move_statusMaxAggregateInputType
  }

  export type GetMove_statusAggregateType<T extends Move_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateMove_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMove_status[P]>
      : GetScalarType<T[P], AggregateMove_status[P]>
  }




  export type Move_statusGroupByArgs = {
    where?: move_statusWhereInput
    orderBy?: Enumerable<move_statusOrderByWithAggregationInput>
    by: Array<Move_statusScalarFieldEnum>
    having?: move_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Move_statusCountAggregateInputType | true
    _avg?: Move_statusAvgAggregateInputType
    _sum?: Move_statusSumAggregateInputType
    _min?: Move_statusMinAggregateInputType
    _max?: Move_statusMaxAggregateInputType
  }


  export type Move_statusGroupByOutputType = {
    id_status: number
    ds_status: string
    _count: Move_statusCountAggregateOutputType | null
    _avg: Move_statusAvgAggregateOutputType | null
    _sum: Move_statusSumAggregateOutputType | null
    _min: Move_statusMinAggregateOutputType | null
    _max: Move_statusMaxAggregateOutputType | null
  }

  type GetMove_statusGroupByPayload<T extends Move_statusGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Move_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Move_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Move_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Move_statusGroupByOutputType[P]>
        }
      >
    >


  export type move_statusSelect = {
    id_status?: boolean
    ds_status?: boolean
    movimentation?: boolean | movimentationFindManyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    _count?: boolean | Move_statusCountOutputTypeArgs
  }

  export type move_statusInclude = {
    movimentation?: boolean | movimentationFindManyArgs
    navagation_plan?: boolean | navagation_planFindManyArgs
    _count?: boolean | Move_statusCountOutputTypeArgs
  }

  export type move_statusGetPayload<
    S extends boolean | null | undefined | move_statusArgs,
    U = keyof S
      > = S extends true
        ? move_status
    : S extends undefined
    ? never
    : S extends move_statusArgs | move_statusFindManyArgs
    ?'include' extends U
    ? move_status  & {
    [P in TrueKeys<S['include']>]:
        P extends 'movimentation' ? Array < movimentationGetPayload<S['include'][P]>>  :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['include'][P]>>  :
        P extends '_count' ? Move_statusCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'movimentation' ? Array < movimentationGetPayload<S['select'][P]>>  :
        P extends 'navagation_plan' ? Array < navagation_planGetPayload<S['select'][P]>>  :
        P extends '_count' ? Move_statusCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof move_status ? move_status[P] : never
  } 
    : move_status
  : move_status


  type move_statusCountArgs = Merge<
    Omit<move_statusFindManyArgs, 'select' | 'include'> & {
      select?: Move_statusCountAggregateInputType | true
    }
  >

  export interface move_statusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Move_status that matches the filter.
     * @param {move_statusFindUniqueArgs} args - Arguments to find a Move_status
     * @example
     * // Get one Move_status
     * const move_status = await prisma.move_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends move_statusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, move_statusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'move_status'> extends True ? CheckSelect<T, Prisma__move_statusClient<move_status>, Prisma__move_statusClient<move_statusGetPayload<T>>> : CheckSelect<T, Prisma__move_statusClient<move_status | null >, Prisma__move_statusClient<move_statusGetPayload<T> | null >>

    /**
     * Find the first Move_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {move_statusFindFirstArgs} args - Arguments to find a Move_status
     * @example
     * // Get one Move_status
     * const move_status = await prisma.move_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends move_statusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, move_statusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'move_status'> extends True ? CheckSelect<T, Prisma__move_statusClient<move_status>, Prisma__move_statusClient<move_statusGetPayload<T>>> : CheckSelect<T, Prisma__move_statusClient<move_status | null >, Prisma__move_statusClient<move_statusGetPayload<T> | null >>

    /**
     * Find zero or more Move_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {move_statusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Move_statuses
     * const move_statuses = await prisma.move_status.findMany()
     * 
     * // Get first 10 Move_statuses
     * const move_statuses = await prisma.move_status.findMany({ take: 10 })
     * 
     * // Only select the `id_status`
     * const move_statusWithId_statusOnly = await prisma.move_status.findMany({ select: { id_status: true } })
     * 
    **/
    findMany<T extends move_statusFindManyArgs>(
      args?: SelectSubset<T, move_statusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<move_status>>, PrismaPromise<Array<move_statusGetPayload<T>>>>

    /**
     * Create a Move_status.
     * @param {move_statusCreateArgs} args - Arguments to create a Move_status.
     * @example
     * // Create one Move_status
     * const Move_status = await prisma.move_status.create({
     *   data: {
     *     // ... data to create a Move_status
     *   }
     * })
     * 
    **/
    create<T extends move_statusCreateArgs>(
      args: SelectSubset<T, move_statusCreateArgs>
    ): CheckSelect<T, Prisma__move_statusClient<move_status>, Prisma__move_statusClient<move_statusGetPayload<T>>>

    /**
     * Create many Move_statuses.
     *     @param {move_statusCreateManyArgs} args - Arguments to create many Move_statuses.
     *     @example
     *     // Create many Move_statuses
     *     const move_status = await prisma.move_status.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends move_statusCreateManyArgs>(
      args?: SelectSubset<T, move_statusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Move_status.
     * @param {move_statusDeleteArgs} args - Arguments to delete one Move_status.
     * @example
     * // Delete one Move_status
     * const Move_status = await prisma.move_status.delete({
     *   where: {
     *     // ... filter to delete one Move_status
     *   }
     * })
     * 
    **/
    delete<T extends move_statusDeleteArgs>(
      args: SelectSubset<T, move_statusDeleteArgs>
    ): CheckSelect<T, Prisma__move_statusClient<move_status>, Prisma__move_statusClient<move_statusGetPayload<T>>>

    /**
     * Update one Move_status.
     * @param {move_statusUpdateArgs} args - Arguments to update one Move_status.
     * @example
     * // Update one Move_status
     * const move_status = await prisma.move_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends move_statusUpdateArgs>(
      args: SelectSubset<T, move_statusUpdateArgs>
    ): CheckSelect<T, Prisma__move_statusClient<move_status>, Prisma__move_statusClient<move_statusGetPayload<T>>>

    /**
     * Delete zero or more Move_statuses.
     * @param {move_statusDeleteManyArgs} args - Arguments to filter Move_statuses to delete.
     * @example
     * // Delete a few Move_statuses
     * const { count } = await prisma.move_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends move_statusDeleteManyArgs>(
      args?: SelectSubset<T, move_statusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Move_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {move_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Move_statuses
     * const move_status = await prisma.move_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends move_statusUpdateManyArgs>(
      args: SelectSubset<T, move_statusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Move_status.
     * @param {move_statusUpsertArgs} args - Arguments to update or create a Move_status.
     * @example
     * // Update or create a Move_status
     * const move_status = await prisma.move_status.upsert({
     *   create: {
     *     // ... data to create a Move_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Move_status we want to update
     *   }
     * })
    **/
    upsert<T extends move_statusUpsertArgs>(
      args: SelectSubset<T, move_statusUpsertArgs>
    ): CheckSelect<T, Prisma__move_statusClient<move_status>, Prisma__move_statusClient<move_statusGetPayload<T>>>

    /**
     * Count the number of Move_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {move_statusCountArgs} args - Arguments to filter Move_statuses to count.
     * @example
     * // Count the number of Move_statuses
     * const count = await prisma.move_status.count({
     *   where: {
     *     // ... the filter for the Move_statuses we want to count
     *   }
     * })
    **/
    count<T extends move_statusCountArgs>(
      args?: Subset<T, move_statusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Move_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Move_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Move_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Move_statusAggregateArgs>(args: Subset<T, Move_statusAggregateArgs>): PrismaPromise<GetMove_statusAggregateType<T>>

    /**
     * Group by Move_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Move_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Move_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Move_statusGroupByArgs['orderBy'] }
        : { orderBy?: Move_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Move_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMove_statusGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for move_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__move_statusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    movimentation<T extends movimentationFindManyArgs = {}>(args?: Subset<T, movimentationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<movimentation>>, PrismaPromise<Array<movimentationGetPayload<T>>>>;

    navagation_plan<T extends navagation_planFindManyArgs = {}>(args?: Subset<T, navagation_planFindManyArgs>): CheckSelect<T, PrismaPromise<Array<navagation_plan>>, PrismaPromise<Array<navagation_planGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * move_status findUnique
   */
  export type move_statusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
    /**
     * Throw an Error if a move_status can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which move_status to fetch.
     * 
    **/
    where: move_statusWhereUniqueInput
  }


  /**
   * move_status findFirst
   */
  export type move_statusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
    /**
     * Throw an Error if a move_status can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which move_status to fetch.
     * 
    **/
    where?: move_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of move_statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<move_statusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for move_statuses.
     * 
    **/
    cursor?: move_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` move_statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` move_statuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of move_statuses.
     * 
    **/
    distinct?: Enumerable<Move_statusScalarFieldEnum>
  }


  /**
   * move_status findMany
   */
  export type move_statusFindManyArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
    /**
     * Filter, which move_statuses to fetch.
     * 
    **/
    where?: move_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of move_statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<move_statusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing move_statuses.
     * 
    **/
    cursor?: move_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` move_statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` move_statuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Move_statusScalarFieldEnum>
  }


  /**
   * move_status create
   */
  export type move_statusCreateArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
    /**
     * The data needed to create a move_status.
     * 
    **/
    data: XOR<move_statusCreateInput, move_statusUncheckedCreateInput>
  }


  /**
   * move_status createMany
   */
  export type move_statusCreateManyArgs = {
    /**
     * The data used to create many move_statuses.
     * 
    **/
    data: Enumerable<move_statusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * move_status update
   */
  export type move_statusUpdateArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
    /**
     * The data needed to update a move_status.
     * 
    **/
    data: XOR<move_statusUpdateInput, move_statusUncheckedUpdateInput>
    /**
     * Choose, which move_status to update.
     * 
    **/
    where: move_statusWhereUniqueInput
  }


  /**
   * move_status updateMany
   */
  export type move_statusUpdateManyArgs = {
    /**
     * The data used to update move_statuses.
     * 
    **/
    data: XOR<move_statusUpdateManyMutationInput, move_statusUncheckedUpdateManyInput>
    /**
     * Filter which move_statuses to update
     * 
    **/
    where?: move_statusWhereInput
  }


  /**
   * move_status upsert
   */
  export type move_statusUpsertArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
    /**
     * The filter to search for the move_status to update in case it exists.
     * 
    **/
    where: move_statusWhereUniqueInput
    /**
     * In case the move_status found by the `where` argument doesn't exist, create a new move_status with this data.
     * 
    **/
    create: XOR<move_statusCreateInput, move_statusUncheckedCreateInput>
    /**
     * In case the move_status was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<move_statusUpdateInput, move_statusUncheckedUpdateInput>
  }


  /**
   * move_status delete
   */
  export type move_statusDeleteArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
    /**
     * Filter which move_status to delete.
     * 
    **/
    where: move_statusWhereUniqueInput
  }


  /**
   * move_status deleteMany
   */
  export type move_statusDeleteManyArgs = {
    /**
     * Filter which move_statuses to delete
     * 
    **/
    where?: move_statusWhereInput
  }


  /**
   * move_status without action
   */
  export type move_statusArgs = {
    /**
     * Select specific fields to fetch from the move_status
     * 
    **/
    select?: move_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: move_statusInclude | null
  }



  /**
   * Model client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id_client: number | null
    cd_company: number | null
  }

  export type ClientSumAggregateOutputType = {
    id_client: number | null
    cd_company: number | null
  }

  export type ClientMinAggregateOutputType = {
    id_client: number | null
    ds_name: string | null
    ds_cpf: string | null
    cd_company: number | null
  }

  export type ClientMaxAggregateOutputType = {
    id_client: number | null
    ds_name: string | null
    ds_cpf: string | null
    cd_company: number | null
  }

  export type ClientCountAggregateOutputType = {
    id_client: number
    ds_name: number
    ds_cpf: number
    cd_company: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id_client?: true
    cd_company?: true
  }

  export type ClientSumAggregateInputType = {
    id_client?: true
    cd_company?: true
  }

  export type ClientMinAggregateInputType = {
    id_client?: true
    ds_name?: true
    ds_cpf?: true
    cd_company?: true
  }

  export type ClientMaxAggregateInputType = {
    id_client?: true
    ds_name?: true
    ds_cpf?: true
    cd_company?: true
  }

  export type ClientCountAggregateInputType = {
    id_client?: true
    ds_name?: true
    ds_cpf?: true
    cd_company?: true
    _all?: true
  }

  export type ClientAggregateArgs = {
    /**
     * Filter which client to aggregate.
     * 
    **/
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     * 
    **/
    orderBy?: Enumerable<clientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs = {
    where?: clientWhereInput
    orderBy?: Enumerable<clientOrderByWithAggregationInput>
    by: Array<ClientScalarFieldEnum>
    having?: clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    id_client: number
    ds_name: string
    ds_cpf: string
    cd_company: number
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type clientSelect = {
    id_client?: boolean
    ds_name?: boolean
    ds_cpf?: boolean
    cd_company?: boolean
    Company?: boolean | companyArgs
    ship_client?: boolean | ship_clientFindManyArgs
    _count?: boolean | ClientCountOutputTypeArgs
  }

  export type clientInclude = {
    Company?: boolean | companyArgs
    ship_client?: boolean | ship_clientFindManyArgs
    _count?: boolean | ClientCountOutputTypeArgs
  }

  export type clientGetPayload<
    S extends boolean | null | undefined | clientArgs,
    U = keyof S
      > = S extends true
        ? client
    : S extends undefined
    ? never
    : S extends clientArgs | clientFindManyArgs
    ?'include' extends U
    ? client  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Company' ? companyGetPayload<S['include'][P]> :
        P extends 'ship_client' ? Array < ship_clientGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClientCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Company' ? companyGetPayload<S['select'][P]> :
        P extends 'ship_client' ? Array < ship_clientGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClientCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof client ? client[P] : never
  } 
    : client
  : client


  type clientCountArgs = Merge<
    Omit<clientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }
  >

  export interface clientDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Client that matches the filter.
     * @param {clientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'client'> extends True ? CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>> : CheckSelect<T, Prisma__clientClient<client | null >, Prisma__clientClient<clientGetPayload<T> | null >>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'client'> extends True ? CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>> : CheckSelect<T, Prisma__clientClient<client | null >, Prisma__clientClient<clientGetPayload<T> | null >>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id_client`
     * const clientWithId_clientOnly = await prisma.client.findMany({ select: { id_client: true } })
     * 
    **/
    findMany<T extends clientFindManyArgs>(
      args?: SelectSubset<T, clientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<client>>, PrismaPromise<Array<clientGetPayload<T>>>>

    /**
     * Create a Client.
     * @param {clientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends clientCreateArgs>(
      args: SelectSubset<T, clientCreateArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Create many Clients.
     *     @param {clientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientCreateManyArgs>(
      args?: SelectSubset<T, clientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {clientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends clientDeleteArgs>(
      args: SelectSubset<T, clientDeleteArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Update one Client.
     * @param {clientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientUpdateArgs>(
      args: SelectSubset<T, clientUpdateArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Delete zero or more Clients.
     * @param {clientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientDeleteManyArgs>(
      args?: SelectSubset<T, clientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientUpdateManyArgs>(
      args: SelectSubset<T, clientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {clientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends clientUpsertArgs>(
      args: SelectSubset<T, clientUpsertArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientCountArgs>(
      args?: Subset<T, clientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>;

    ship_client<T extends ship_clientFindManyArgs = {}>(args?: Subset<T, ship_clientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ship_client>>, PrismaPromise<Array<ship_clientGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * client findUnique
   */
  export type clientFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Throw an Error if a client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which client to fetch.
     * 
    **/
    where: clientWhereUniqueInput
  }


  /**
   * client findFirst
   */
  export type clientFindFirstArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Throw an Error if a client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which client to fetch.
     * 
    **/
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     * 
    **/
    orderBy?: Enumerable<clientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     * 
    **/
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     * 
    **/
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * client findMany
   */
  export type clientFindManyArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Filter, which clients to fetch.
     * 
    **/
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     * 
    **/
    orderBy?: Enumerable<clientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     * 
    **/
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * client create
   */
  export type clientCreateArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * The data needed to create a client.
     * 
    **/
    data: XOR<clientCreateInput, clientUncheckedCreateInput>
  }


  /**
   * client createMany
   */
  export type clientCreateManyArgs = {
    /**
     * The data used to create many clients.
     * 
    **/
    data: Enumerable<clientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * client update
   */
  export type clientUpdateArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * The data needed to update a client.
     * 
    **/
    data: XOR<clientUpdateInput, clientUncheckedUpdateInput>
    /**
     * Choose, which client to update.
     * 
    **/
    where: clientWhereUniqueInput
  }


  /**
   * client updateMany
   */
  export type clientUpdateManyArgs = {
    /**
     * The data used to update clients.
     * 
    **/
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     * 
    **/
    where?: clientWhereInput
  }


  /**
   * client upsert
   */
  export type clientUpsertArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * The filter to search for the client to update in case it exists.
     * 
    **/
    where: clientWhereUniqueInput
    /**
     * In case the client found by the `where` argument doesn't exist, create a new client with this data.
     * 
    **/
    create: XOR<clientCreateInput, clientUncheckedCreateInput>
    /**
     * In case the client was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clientUpdateInput, clientUncheckedUpdateInput>
  }


  /**
   * client delete
   */
  export type clientDeleteArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Filter which client to delete.
     * 
    **/
    where: clientWhereUniqueInput
  }


  /**
   * client deleteMany
   */
  export type clientDeleteManyArgs = {
    /**
     * Filter which clients to delete
     * 
    **/
    where?: clientWhereInput
  }


  /**
   * client without action
   */
  export type clientArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
  }



  /**
   * Model mariner
   */


  export type AggregateMariner = {
    _count: MarinerCountAggregateOutputType | null
    _avg: MarinerAvgAggregateOutputType | null
    _sum: MarinerSumAggregateOutputType | null
    _min: MarinerMinAggregateOutputType | null
    _max: MarinerMaxAggregateOutputType | null
  }

  export type MarinerAvgAggregateOutputType = {
    id_mariner: number | null
    cd_company: number | null
  }

  export type MarinerSumAggregateOutputType = {
    id_mariner: number | null
    cd_company: number | null
  }

  export type MarinerMinAggregateOutputType = {
    id_mariner: number | null
    ds_name: string | null
    ds_cpf: string | null
    cd_company: number | null
  }

  export type MarinerMaxAggregateOutputType = {
    id_mariner: number | null
    ds_name: string | null
    ds_cpf: string | null
    cd_company: number | null
  }

  export type MarinerCountAggregateOutputType = {
    id_mariner: number
    ds_name: number
    ds_cpf: number
    cd_company: number
    _all: number
  }


  export type MarinerAvgAggregateInputType = {
    id_mariner?: true
    cd_company?: true
  }

  export type MarinerSumAggregateInputType = {
    id_mariner?: true
    cd_company?: true
  }

  export type MarinerMinAggregateInputType = {
    id_mariner?: true
    ds_name?: true
    ds_cpf?: true
    cd_company?: true
  }

  export type MarinerMaxAggregateInputType = {
    id_mariner?: true
    ds_name?: true
    ds_cpf?: true
    cd_company?: true
  }

  export type MarinerCountAggregateInputType = {
    id_mariner?: true
    ds_name?: true
    ds_cpf?: true
    cd_company?: true
    _all?: true
  }

  export type MarinerAggregateArgs = {
    /**
     * Filter which mariner to aggregate.
     * 
    **/
    where?: marinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mariners to fetch.
     * 
    **/
    orderBy?: Enumerable<marinerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: marinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mariners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mariners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mariners
    **/
    _count?: true | MarinerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarinerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarinerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarinerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarinerMaxAggregateInputType
  }

  export type GetMarinerAggregateType<T extends MarinerAggregateArgs> = {
        [P in keyof T & keyof AggregateMariner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMariner[P]>
      : GetScalarType<T[P], AggregateMariner[P]>
  }




  export type MarinerGroupByArgs = {
    where?: marinerWhereInput
    orderBy?: Enumerable<marinerOrderByWithAggregationInput>
    by: Array<MarinerScalarFieldEnum>
    having?: marinerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarinerCountAggregateInputType | true
    _avg?: MarinerAvgAggregateInputType
    _sum?: MarinerSumAggregateInputType
    _min?: MarinerMinAggregateInputType
    _max?: MarinerMaxAggregateInputType
  }


  export type MarinerGroupByOutputType = {
    id_mariner: number
    ds_name: string
    ds_cpf: string
    cd_company: number
    _count: MarinerCountAggregateOutputType | null
    _avg: MarinerAvgAggregateOutputType | null
    _sum: MarinerSumAggregateOutputType | null
    _min: MarinerMinAggregateOutputType | null
    _max: MarinerMaxAggregateOutputType | null
  }

  type GetMarinerGroupByPayload<T extends MarinerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MarinerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarinerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarinerGroupByOutputType[P]>
            : GetScalarType<T[P], MarinerGroupByOutputType[P]>
        }
      >
    >


  export type marinerSelect = {
    id_mariner?: boolean
    ds_name?: boolean
    ds_cpf?: boolean
    cd_company?: boolean
    Company?: boolean | companyArgs
    ship_mariner?: boolean | ship_marinerFindManyArgs
    _count?: boolean | MarinerCountOutputTypeArgs
  }

  export type marinerInclude = {
    Company?: boolean | companyArgs
    ship_mariner?: boolean | ship_marinerFindManyArgs
    _count?: boolean | MarinerCountOutputTypeArgs
  }

  export type marinerGetPayload<
    S extends boolean | null | undefined | marinerArgs,
    U = keyof S
      > = S extends true
        ? mariner
    : S extends undefined
    ? never
    : S extends marinerArgs | marinerFindManyArgs
    ?'include' extends U
    ? mariner  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Company' ? companyGetPayload<S['include'][P]> :
        P extends 'ship_mariner' ? Array < ship_marinerGetPayload<S['include'][P]>>  :
        P extends '_count' ? MarinerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Company' ? companyGetPayload<S['select'][P]> :
        P extends 'ship_mariner' ? Array < ship_marinerGetPayload<S['select'][P]>>  :
        P extends '_count' ? MarinerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof mariner ? mariner[P] : never
  } 
    : mariner
  : mariner


  type marinerCountArgs = Merge<
    Omit<marinerFindManyArgs, 'select' | 'include'> & {
      select?: MarinerCountAggregateInputType | true
    }
  >

  export interface marinerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Mariner that matches the filter.
     * @param {marinerFindUniqueArgs} args - Arguments to find a Mariner
     * @example
     * // Get one Mariner
     * const mariner = await prisma.mariner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends marinerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, marinerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mariner'> extends True ? CheckSelect<T, Prisma__marinerClient<mariner>, Prisma__marinerClient<marinerGetPayload<T>>> : CheckSelect<T, Prisma__marinerClient<mariner | null >, Prisma__marinerClient<marinerGetPayload<T> | null >>

    /**
     * Find the first Mariner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marinerFindFirstArgs} args - Arguments to find a Mariner
     * @example
     * // Get one Mariner
     * const mariner = await prisma.mariner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends marinerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, marinerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mariner'> extends True ? CheckSelect<T, Prisma__marinerClient<mariner>, Prisma__marinerClient<marinerGetPayload<T>>> : CheckSelect<T, Prisma__marinerClient<mariner | null >, Prisma__marinerClient<marinerGetPayload<T> | null >>

    /**
     * Find zero or more Mariners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marinerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mariners
     * const mariners = await prisma.mariner.findMany()
     * 
     * // Get first 10 Mariners
     * const mariners = await prisma.mariner.findMany({ take: 10 })
     * 
     * // Only select the `id_mariner`
     * const marinerWithId_marinerOnly = await prisma.mariner.findMany({ select: { id_mariner: true } })
     * 
    **/
    findMany<T extends marinerFindManyArgs>(
      args?: SelectSubset<T, marinerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<mariner>>, PrismaPromise<Array<marinerGetPayload<T>>>>

    /**
     * Create a Mariner.
     * @param {marinerCreateArgs} args - Arguments to create a Mariner.
     * @example
     * // Create one Mariner
     * const Mariner = await prisma.mariner.create({
     *   data: {
     *     // ... data to create a Mariner
     *   }
     * })
     * 
    **/
    create<T extends marinerCreateArgs>(
      args: SelectSubset<T, marinerCreateArgs>
    ): CheckSelect<T, Prisma__marinerClient<mariner>, Prisma__marinerClient<marinerGetPayload<T>>>

    /**
     * Create many Mariners.
     *     @param {marinerCreateManyArgs} args - Arguments to create many Mariners.
     *     @example
     *     // Create many Mariners
     *     const mariner = await prisma.mariner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends marinerCreateManyArgs>(
      args?: SelectSubset<T, marinerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mariner.
     * @param {marinerDeleteArgs} args - Arguments to delete one Mariner.
     * @example
     * // Delete one Mariner
     * const Mariner = await prisma.mariner.delete({
     *   where: {
     *     // ... filter to delete one Mariner
     *   }
     * })
     * 
    **/
    delete<T extends marinerDeleteArgs>(
      args: SelectSubset<T, marinerDeleteArgs>
    ): CheckSelect<T, Prisma__marinerClient<mariner>, Prisma__marinerClient<marinerGetPayload<T>>>

    /**
     * Update one Mariner.
     * @param {marinerUpdateArgs} args - Arguments to update one Mariner.
     * @example
     * // Update one Mariner
     * const mariner = await prisma.mariner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends marinerUpdateArgs>(
      args: SelectSubset<T, marinerUpdateArgs>
    ): CheckSelect<T, Prisma__marinerClient<mariner>, Prisma__marinerClient<marinerGetPayload<T>>>

    /**
     * Delete zero or more Mariners.
     * @param {marinerDeleteManyArgs} args - Arguments to filter Mariners to delete.
     * @example
     * // Delete a few Mariners
     * const { count } = await prisma.mariner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends marinerDeleteManyArgs>(
      args?: SelectSubset<T, marinerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mariners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marinerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mariners
     * const mariner = await prisma.mariner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends marinerUpdateManyArgs>(
      args: SelectSubset<T, marinerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mariner.
     * @param {marinerUpsertArgs} args - Arguments to update or create a Mariner.
     * @example
     * // Update or create a Mariner
     * const mariner = await prisma.mariner.upsert({
     *   create: {
     *     // ... data to create a Mariner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mariner we want to update
     *   }
     * })
    **/
    upsert<T extends marinerUpsertArgs>(
      args: SelectSubset<T, marinerUpsertArgs>
    ): CheckSelect<T, Prisma__marinerClient<mariner>, Prisma__marinerClient<marinerGetPayload<T>>>

    /**
     * Count the number of Mariners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marinerCountArgs} args - Arguments to filter Mariners to count.
     * @example
     * // Count the number of Mariners
     * const count = await prisma.mariner.count({
     *   where: {
     *     // ... the filter for the Mariners we want to count
     *   }
     * })
    **/
    count<T extends marinerCountArgs>(
      args?: Subset<T, marinerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarinerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mariner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarinerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarinerAggregateArgs>(args: Subset<T, MarinerAggregateArgs>): PrismaPromise<GetMarinerAggregateType<T>>

    /**
     * Group by Mariner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarinerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarinerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarinerGroupByArgs['orderBy'] }
        : { orderBy?: MarinerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarinerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarinerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for mariner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__marinerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>;

    ship_mariner<T extends ship_marinerFindManyArgs = {}>(args?: Subset<T, ship_marinerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ship_mariner>>, PrismaPromise<Array<ship_marinerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * mariner findUnique
   */
  export type marinerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
    /**
     * Throw an Error if a mariner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which mariner to fetch.
     * 
    **/
    where: marinerWhereUniqueInput
  }


  /**
   * mariner findFirst
   */
  export type marinerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
    /**
     * Throw an Error if a mariner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which mariner to fetch.
     * 
    **/
    where?: marinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mariners to fetch.
     * 
    **/
    orderBy?: Enumerable<marinerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mariners.
     * 
    **/
    cursor?: marinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mariners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mariners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mariners.
     * 
    **/
    distinct?: Enumerable<MarinerScalarFieldEnum>
  }


  /**
   * mariner findMany
   */
  export type marinerFindManyArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
    /**
     * Filter, which mariners to fetch.
     * 
    **/
    where?: marinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mariners to fetch.
     * 
    **/
    orderBy?: Enumerable<marinerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mariners.
     * 
    **/
    cursor?: marinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mariners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mariners.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MarinerScalarFieldEnum>
  }


  /**
   * mariner create
   */
  export type marinerCreateArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
    /**
     * The data needed to create a mariner.
     * 
    **/
    data: XOR<marinerCreateInput, marinerUncheckedCreateInput>
  }


  /**
   * mariner createMany
   */
  export type marinerCreateManyArgs = {
    /**
     * The data used to create many mariners.
     * 
    **/
    data: Enumerable<marinerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mariner update
   */
  export type marinerUpdateArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
    /**
     * The data needed to update a mariner.
     * 
    **/
    data: XOR<marinerUpdateInput, marinerUncheckedUpdateInput>
    /**
     * Choose, which mariner to update.
     * 
    **/
    where: marinerWhereUniqueInput
  }


  /**
   * mariner updateMany
   */
  export type marinerUpdateManyArgs = {
    /**
     * The data used to update mariners.
     * 
    **/
    data: XOR<marinerUpdateManyMutationInput, marinerUncheckedUpdateManyInput>
    /**
     * Filter which mariners to update
     * 
    **/
    where?: marinerWhereInput
  }


  /**
   * mariner upsert
   */
  export type marinerUpsertArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
    /**
     * The filter to search for the mariner to update in case it exists.
     * 
    **/
    where: marinerWhereUniqueInput
    /**
     * In case the mariner found by the `where` argument doesn't exist, create a new mariner with this data.
     * 
    **/
    create: XOR<marinerCreateInput, marinerUncheckedCreateInput>
    /**
     * In case the mariner was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<marinerUpdateInput, marinerUncheckedUpdateInput>
  }


  /**
   * mariner delete
   */
  export type marinerDeleteArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
    /**
     * Filter which mariner to delete.
     * 
    **/
    where: marinerWhereUniqueInput
  }


  /**
   * mariner deleteMany
   */
  export type marinerDeleteManyArgs = {
    /**
     * Filter which mariners to delete
     * 
    **/
    where?: marinerWhereInput
  }


  /**
   * mariner without action
   */
  export type marinerArgs = {
    /**
     * Select specific fields to fetch from the mariner
     * 
    **/
    select?: marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: marinerInclude | null
  }



  /**
   * Model ship
   */


  export type AggregateShip = {
    _count: ShipCountAggregateOutputType | null
    _avg: ShipAvgAggregateOutputType | null
    _sum: ShipSumAggregateOutputType | null
    _min: ShipMinAggregateOutputType | null
    _max: ShipMaxAggregateOutputType | null
  }

  export type ShipAvgAggregateOutputType = {
    id_ship: number | null
    cd_company: number | null
  }

  export type ShipSumAggregateOutputType = {
    id_ship: number | null
    cd_company: number | null
  }

  export type ShipMinAggregateOutputType = {
    id_ship: number | null
    ds_ship: string | null
    cd_company: number | null
  }

  export type ShipMaxAggregateOutputType = {
    id_ship: number | null
    ds_ship: string | null
    cd_company: number | null
  }

  export type ShipCountAggregateOutputType = {
    id_ship: number
    ds_ship: number
    cd_company: number
    _all: number
  }


  export type ShipAvgAggregateInputType = {
    id_ship?: true
    cd_company?: true
  }

  export type ShipSumAggregateInputType = {
    id_ship?: true
    cd_company?: true
  }

  export type ShipMinAggregateInputType = {
    id_ship?: true
    ds_ship?: true
    cd_company?: true
  }

  export type ShipMaxAggregateInputType = {
    id_ship?: true
    ds_ship?: true
    cd_company?: true
  }

  export type ShipCountAggregateInputType = {
    id_ship?: true
    ds_ship?: true
    cd_company?: true
    _all?: true
  }

  export type ShipAggregateArgs = {
    /**
     * Filter which ship to aggregate.
     * 
    **/
    where?: shipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ships to fetch.
     * 
    **/
    orderBy?: Enumerable<shipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: shipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ships
    **/
    _count?: true | ShipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipMaxAggregateInputType
  }

  export type GetShipAggregateType<T extends ShipAggregateArgs> = {
        [P in keyof T & keyof AggregateShip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShip[P]>
      : GetScalarType<T[P], AggregateShip[P]>
  }




  export type ShipGroupByArgs = {
    where?: shipWhereInput
    orderBy?: Enumerable<shipOrderByWithAggregationInput>
    by: Array<ShipScalarFieldEnum>
    having?: shipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipCountAggregateInputType | true
    _avg?: ShipAvgAggregateInputType
    _sum?: ShipSumAggregateInputType
    _min?: ShipMinAggregateInputType
    _max?: ShipMaxAggregateInputType
  }


  export type ShipGroupByOutputType = {
    id_ship: number
    ds_ship: string
    cd_company: number
    _count: ShipCountAggregateOutputType | null
    _avg: ShipAvgAggregateOutputType | null
    _sum: ShipSumAggregateOutputType | null
    _min: ShipMinAggregateOutputType | null
    _max: ShipMaxAggregateOutputType | null
  }

  type GetShipGroupByPayload<T extends ShipGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipGroupByOutputType[P]>
            : GetScalarType<T[P], ShipGroupByOutputType[P]>
        }
      >
    >


  export type shipSelect = {
    id_ship?: boolean
    ds_ship?: boolean
    cd_company?: boolean
    Company?: boolean | companyArgs
    ship_client?: boolean | ship_clientFindManyArgs
    ship_mariner?: boolean | ship_marinerFindManyArgs
    _count?: boolean | ShipCountOutputTypeArgs
  }

  export type shipInclude = {
    Company?: boolean | companyArgs
    ship_client?: boolean | ship_clientFindManyArgs
    ship_mariner?: boolean | ship_marinerFindManyArgs
    _count?: boolean | ShipCountOutputTypeArgs
  }

  export type shipGetPayload<
    S extends boolean | null | undefined | shipArgs,
    U = keyof S
      > = S extends true
        ? ship
    : S extends undefined
    ? never
    : S extends shipArgs | shipFindManyArgs
    ?'include' extends U
    ? ship  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Company' ? companyGetPayload<S['include'][P]> :
        P extends 'ship_client' ? Array < ship_clientGetPayload<S['include'][P]>>  :
        P extends 'ship_mariner' ? Array < ship_marinerGetPayload<S['include'][P]>>  :
        P extends '_count' ? ShipCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Company' ? companyGetPayload<S['select'][P]> :
        P extends 'ship_client' ? Array < ship_clientGetPayload<S['select'][P]>>  :
        P extends 'ship_mariner' ? Array < ship_marinerGetPayload<S['select'][P]>>  :
        P extends '_count' ? ShipCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ship ? ship[P] : never
  } 
    : ship
  : ship


  type shipCountArgs = Merge<
    Omit<shipFindManyArgs, 'select' | 'include'> & {
      select?: ShipCountAggregateInputType | true
    }
  >

  export interface shipDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ship that matches the filter.
     * @param {shipFindUniqueArgs} args - Arguments to find a Ship
     * @example
     * // Get one Ship
     * const ship = await prisma.ship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends shipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, shipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ship'> extends True ? CheckSelect<T, Prisma__shipClient<ship>, Prisma__shipClient<shipGetPayload<T>>> : CheckSelect<T, Prisma__shipClient<ship | null >, Prisma__shipClient<shipGetPayload<T> | null >>

    /**
     * Find the first Ship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipFindFirstArgs} args - Arguments to find a Ship
     * @example
     * // Get one Ship
     * const ship = await prisma.ship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends shipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, shipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ship'> extends True ? CheckSelect<T, Prisma__shipClient<ship>, Prisma__shipClient<shipGetPayload<T>>> : CheckSelect<T, Prisma__shipClient<ship | null >, Prisma__shipClient<shipGetPayload<T> | null >>

    /**
     * Find zero or more Ships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ships
     * const ships = await prisma.ship.findMany()
     * 
     * // Get first 10 Ships
     * const ships = await prisma.ship.findMany({ take: 10 })
     * 
     * // Only select the `id_ship`
     * const shipWithId_shipOnly = await prisma.ship.findMany({ select: { id_ship: true } })
     * 
    **/
    findMany<T extends shipFindManyArgs>(
      args?: SelectSubset<T, shipFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ship>>, PrismaPromise<Array<shipGetPayload<T>>>>

    /**
     * Create a Ship.
     * @param {shipCreateArgs} args - Arguments to create a Ship.
     * @example
     * // Create one Ship
     * const Ship = await prisma.ship.create({
     *   data: {
     *     // ... data to create a Ship
     *   }
     * })
     * 
    **/
    create<T extends shipCreateArgs>(
      args: SelectSubset<T, shipCreateArgs>
    ): CheckSelect<T, Prisma__shipClient<ship>, Prisma__shipClient<shipGetPayload<T>>>

    /**
     * Create many Ships.
     *     @param {shipCreateManyArgs} args - Arguments to create many Ships.
     *     @example
     *     // Create many Ships
     *     const ship = await prisma.ship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends shipCreateManyArgs>(
      args?: SelectSubset<T, shipCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ship.
     * @param {shipDeleteArgs} args - Arguments to delete one Ship.
     * @example
     * // Delete one Ship
     * const Ship = await prisma.ship.delete({
     *   where: {
     *     // ... filter to delete one Ship
     *   }
     * })
     * 
    **/
    delete<T extends shipDeleteArgs>(
      args: SelectSubset<T, shipDeleteArgs>
    ): CheckSelect<T, Prisma__shipClient<ship>, Prisma__shipClient<shipGetPayload<T>>>

    /**
     * Update one Ship.
     * @param {shipUpdateArgs} args - Arguments to update one Ship.
     * @example
     * // Update one Ship
     * const ship = await prisma.ship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends shipUpdateArgs>(
      args: SelectSubset<T, shipUpdateArgs>
    ): CheckSelect<T, Prisma__shipClient<ship>, Prisma__shipClient<shipGetPayload<T>>>

    /**
     * Delete zero or more Ships.
     * @param {shipDeleteManyArgs} args - Arguments to filter Ships to delete.
     * @example
     * // Delete a few Ships
     * const { count } = await prisma.ship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends shipDeleteManyArgs>(
      args?: SelectSubset<T, shipDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ships
     * const ship = await prisma.ship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends shipUpdateManyArgs>(
      args: SelectSubset<T, shipUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ship.
     * @param {shipUpsertArgs} args - Arguments to update or create a Ship.
     * @example
     * // Update or create a Ship
     * const ship = await prisma.ship.upsert({
     *   create: {
     *     // ... data to create a Ship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ship we want to update
     *   }
     * })
    **/
    upsert<T extends shipUpsertArgs>(
      args: SelectSubset<T, shipUpsertArgs>
    ): CheckSelect<T, Prisma__shipClient<ship>, Prisma__shipClient<shipGetPayload<T>>>

    /**
     * Count the number of Ships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipCountArgs} args - Arguments to filter Ships to count.
     * @example
     * // Count the number of Ships
     * const count = await prisma.ship.count({
     *   where: {
     *     // ... the filter for the Ships we want to count
     *   }
     * })
    **/
    count<T extends shipCountArgs>(
      args?: Subset<T, shipCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipAggregateArgs>(args: Subset<T, ShipAggregateArgs>): PrismaPromise<GetShipAggregateType<T>>

    /**
     * Group by Ship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipGroupByArgs['orderBy'] }
        : { orderBy?: ShipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__shipClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>;

    ship_client<T extends ship_clientFindManyArgs = {}>(args?: Subset<T, ship_clientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ship_client>>, PrismaPromise<Array<ship_clientGetPayload<T>>>>;

    ship_mariner<T extends ship_marinerFindManyArgs = {}>(args?: Subset<T, ship_marinerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ship_mariner>>, PrismaPromise<Array<ship_marinerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ship findUnique
   */
  export type shipFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
    /**
     * Throw an Error if a ship can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ship to fetch.
     * 
    **/
    where: shipWhereUniqueInput
  }


  /**
   * ship findFirst
   */
  export type shipFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
    /**
     * Throw an Error if a ship can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ship to fetch.
     * 
    **/
    where?: shipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ships to fetch.
     * 
    **/
    orderBy?: Enumerable<shipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ships.
     * 
    **/
    cursor?: shipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ships.
     * 
    **/
    distinct?: Enumerable<ShipScalarFieldEnum>
  }


  /**
   * ship findMany
   */
  export type shipFindManyArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
    /**
     * Filter, which ships to fetch.
     * 
    **/
    where?: shipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ships to fetch.
     * 
    **/
    orderBy?: Enumerable<shipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ships.
     * 
    **/
    cursor?: shipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ships.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShipScalarFieldEnum>
  }


  /**
   * ship create
   */
  export type shipCreateArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
    /**
     * The data needed to create a ship.
     * 
    **/
    data: XOR<shipCreateInput, shipUncheckedCreateInput>
  }


  /**
   * ship createMany
   */
  export type shipCreateManyArgs = {
    /**
     * The data used to create many ships.
     * 
    **/
    data: Enumerable<shipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ship update
   */
  export type shipUpdateArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
    /**
     * The data needed to update a ship.
     * 
    **/
    data: XOR<shipUpdateInput, shipUncheckedUpdateInput>
    /**
     * Choose, which ship to update.
     * 
    **/
    where: shipWhereUniqueInput
  }


  /**
   * ship updateMany
   */
  export type shipUpdateManyArgs = {
    /**
     * The data used to update ships.
     * 
    **/
    data: XOR<shipUpdateManyMutationInput, shipUncheckedUpdateManyInput>
    /**
     * Filter which ships to update
     * 
    **/
    where?: shipWhereInput
  }


  /**
   * ship upsert
   */
  export type shipUpsertArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
    /**
     * The filter to search for the ship to update in case it exists.
     * 
    **/
    where: shipWhereUniqueInput
    /**
     * In case the ship found by the `where` argument doesn't exist, create a new ship with this data.
     * 
    **/
    create: XOR<shipCreateInput, shipUncheckedCreateInput>
    /**
     * In case the ship was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<shipUpdateInput, shipUncheckedUpdateInput>
  }


  /**
   * ship delete
   */
  export type shipDeleteArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
    /**
     * Filter which ship to delete.
     * 
    **/
    where: shipWhereUniqueInput
  }


  /**
   * ship deleteMany
   */
  export type shipDeleteManyArgs = {
    /**
     * Filter which ships to delete
     * 
    **/
    where?: shipWhereInput
  }


  /**
   * ship without action
   */
  export type shipArgs = {
    /**
     * Select specific fields to fetch from the ship
     * 
    **/
    select?: shipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: shipInclude | null
  }



  /**
   * Model ship_mariner
   */


  export type AggregateShip_mariner = {
    _count: Ship_marinerCountAggregateOutputType | null
    _avg: Ship_marinerAvgAggregateOutputType | null
    _sum: Ship_marinerSumAggregateOutputType | null
    _min: Ship_marinerMinAggregateOutputType | null
    _max: Ship_marinerMaxAggregateOutputType | null
  }

  export type Ship_marinerAvgAggregateOutputType = {
    cd_ship: number | null
    cd_mariner: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_marinerSumAggregateOutputType = {
    cd_ship: number | null
    cd_mariner: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_marinerMinAggregateOutputType = {
    cd_ship: number | null
    cd_mariner: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_marinerMaxAggregateOutputType = {
    cd_ship: number | null
    cd_mariner: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_marinerCountAggregateOutputType = {
    cd_ship: number
    cd_mariner: number
    id_cliente_mariner: number
    _all: number
  }


  export type Ship_marinerAvgAggregateInputType = {
    cd_ship?: true
    cd_mariner?: true
    id_cliente_mariner?: true
  }

  export type Ship_marinerSumAggregateInputType = {
    cd_ship?: true
    cd_mariner?: true
    id_cliente_mariner?: true
  }

  export type Ship_marinerMinAggregateInputType = {
    cd_ship?: true
    cd_mariner?: true
    id_cliente_mariner?: true
  }

  export type Ship_marinerMaxAggregateInputType = {
    cd_ship?: true
    cd_mariner?: true
    id_cliente_mariner?: true
  }

  export type Ship_marinerCountAggregateInputType = {
    cd_ship?: true
    cd_mariner?: true
    id_cliente_mariner?: true
    _all?: true
  }

  export type Ship_marinerAggregateArgs = {
    /**
     * Filter which ship_mariner to aggregate.
     * 
    **/
    where?: ship_marinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ship_mariners to fetch.
     * 
    **/
    orderBy?: Enumerable<ship_marinerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ship_marinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ship_mariners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ship_mariners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ship_mariners
    **/
    _count?: true | Ship_marinerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ship_marinerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ship_marinerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ship_marinerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ship_marinerMaxAggregateInputType
  }

  export type GetShip_marinerAggregateType<T extends Ship_marinerAggregateArgs> = {
        [P in keyof T & keyof AggregateShip_mariner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShip_mariner[P]>
      : GetScalarType<T[P], AggregateShip_mariner[P]>
  }




  export type Ship_marinerGroupByArgs = {
    where?: ship_marinerWhereInput
    orderBy?: Enumerable<ship_marinerOrderByWithAggregationInput>
    by: Array<Ship_marinerScalarFieldEnum>
    having?: ship_marinerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ship_marinerCountAggregateInputType | true
    _avg?: Ship_marinerAvgAggregateInputType
    _sum?: Ship_marinerSumAggregateInputType
    _min?: Ship_marinerMinAggregateInputType
    _max?: Ship_marinerMaxAggregateInputType
  }


  export type Ship_marinerGroupByOutputType = {
    cd_ship: number
    cd_mariner: number
    id_cliente_mariner: number
    _count: Ship_marinerCountAggregateOutputType | null
    _avg: Ship_marinerAvgAggregateOutputType | null
    _sum: Ship_marinerSumAggregateOutputType | null
    _min: Ship_marinerMinAggregateOutputType | null
    _max: Ship_marinerMaxAggregateOutputType | null
  }

  type GetShip_marinerGroupByPayload<T extends Ship_marinerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Ship_marinerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ship_marinerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ship_marinerGroupByOutputType[P]>
            : GetScalarType<T[P], Ship_marinerGroupByOutputType[P]>
        }
      >
    >


  export type ship_marinerSelect = {
    cd_ship?: boolean
    cd_mariner?: boolean
    id_cliente_mariner?: boolean
    Mariner?: boolean | marinerArgs
    Ship?: boolean | shipArgs
  }

  export type ship_marinerInclude = {
    Mariner?: boolean | marinerArgs
    Ship?: boolean | shipArgs
  }

  export type ship_marinerGetPayload<
    S extends boolean | null | undefined | ship_marinerArgs,
    U = keyof S
      > = S extends true
        ? ship_mariner
    : S extends undefined
    ? never
    : S extends ship_marinerArgs | ship_marinerFindManyArgs
    ?'include' extends U
    ? ship_mariner  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Mariner' ? marinerGetPayload<S['include'][P]> :
        P extends 'Ship' ? shipGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Mariner' ? marinerGetPayload<S['select'][P]> :
        P extends 'Ship' ? shipGetPayload<S['select'][P]> :  P extends keyof ship_mariner ? ship_mariner[P] : never
  } 
    : ship_mariner
  : ship_mariner


  type ship_marinerCountArgs = Merge<
    Omit<ship_marinerFindManyArgs, 'select' | 'include'> & {
      select?: Ship_marinerCountAggregateInputType | true
    }
  >

  export interface ship_marinerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ship_mariner that matches the filter.
     * @param {ship_marinerFindUniqueArgs} args - Arguments to find a Ship_mariner
     * @example
     * // Get one Ship_mariner
     * const ship_mariner = await prisma.ship_mariner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ship_marinerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ship_marinerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ship_mariner'> extends True ? CheckSelect<T, Prisma__ship_marinerClient<ship_mariner>, Prisma__ship_marinerClient<ship_marinerGetPayload<T>>> : CheckSelect<T, Prisma__ship_marinerClient<ship_mariner | null >, Prisma__ship_marinerClient<ship_marinerGetPayload<T> | null >>

    /**
     * Find the first Ship_mariner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_marinerFindFirstArgs} args - Arguments to find a Ship_mariner
     * @example
     * // Get one Ship_mariner
     * const ship_mariner = await prisma.ship_mariner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ship_marinerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ship_marinerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ship_mariner'> extends True ? CheckSelect<T, Prisma__ship_marinerClient<ship_mariner>, Prisma__ship_marinerClient<ship_marinerGetPayload<T>>> : CheckSelect<T, Prisma__ship_marinerClient<ship_mariner | null >, Prisma__ship_marinerClient<ship_marinerGetPayload<T> | null >>

    /**
     * Find zero or more Ship_mariners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_marinerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ship_mariners
     * const ship_mariners = await prisma.ship_mariner.findMany()
     * 
     * // Get first 10 Ship_mariners
     * const ship_mariners = await prisma.ship_mariner.findMany({ take: 10 })
     * 
     * // Only select the `cd_ship`
     * const ship_marinerWithCd_shipOnly = await prisma.ship_mariner.findMany({ select: { cd_ship: true } })
     * 
    **/
    findMany<T extends ship_marinerFindManyArgs>(
      args?: SelectSubset<T, ship_marinerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ship_mariner>>, PrismaPromise<Array<ship_marinerGetPayload<T>>>>

    /**
     * Create a Ship_mariner.
     * @param {ship_marinerCreateArgs} args - Arguments to create a Ship_mariner.
     * @example
     * // Create one Ship_mariner
     * const Ship_mariner = await prisma.ship_mariner.create({
     *   data: {
     *     // ... data to create a Ship_mariner
     *   }
     * })
     * 
    **/
    create<T extends ship_marinerCreateArgs>(
      args: SelectSubset<T, ship_marinerCreateArgs>
    ): CheckSelect<T, Prisma__ship_marinerClient<ship_mariner>, Prisma__ship_marinerClient<ship_marinerGetPayload<T>>>

    /**
     * Create many Ship_mariners.
     *     @param {ship_marinerCreateManyArgs} args - Arguments to create many Ship_mariners.
     *     @example
     *     // Create many Ship_mariners
     *     const ship_mariner = await prisma.ship_mariner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ship_marinerCreateManyArgs>(
      args?: SelectSubset<T, ship_marinerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ship_mariner.
     * @param {ship_marinerDeleteArgs} args - Arguments to delete one Ship_mariner.
     * @example
     * // Delete one Ship_mariner
     * const Ship_mariner = await prisma.ship_mariner.delete({
     *   where: {
     *     // ... filter to delete one Ship_mariner
     *   }
     * })
     * 
    **/
    delete<T extends ship_marinerDeleteArgs>(
      args: SelectSubset<T, ship_marinerDeleteArgs>
    ): CheckSelect<T, Prisma__ship_marinerClient<ship_mariner>, Prisma__ship_marinerClient<ship_marinerGetPayload<T>>>

    /**
     * Update one Ship_mariner.
     * @param {ship_marinerUpdateArgs} args - Arguments to update one Ship_mariner.
     * @example
     * // Update one Ship_mariner
     * const ship_mariner = await prisma.ship_mariner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ship_marinerUpdateArgs>(
      args: SelectSubset<T, ship_marinerUpdateArgs>
    ): CheckSelect<T, Prisma__ship_marinerClient<ship_mariner>, Prisma__ship_marinerClient<ship_marinerGetPayload<T>>>

    /**
     * Delete zero or more Ship_mariners.
     * @param {ship_marinerDeleteManyArgs} args - Arguments to filter Ship_mariners to delete.
     * @example
     * // Delete a few Ship_mariners
     * const { count } = await prisma.ship_mariner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ship_marinerDeleteManyArgs>(
      args?: SelectSubset<T, ship_marinerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ship_mariners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_marinerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ship_mariners
     * const ship_mariner = await prisma.ship_mariner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ship_marinerUpdateManyArgs>(
      args: SelectSubset<T, ship_marinerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ship_mariner.
     * @param {ship_marinerUpsertArgs} args - Arguments to update or create a Ship_mariner.
     * @example
     * // Update or create a Ship_mariner
     * const ship_mariner = await prisma.ship_mariner.upsert({
     *   create: {
     *     // ... data to create a Ship_mariner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ship_mariner we want to update
     *   }
     * })
    **/
    upsert<T extends ship_marinerUpsertArgs>(
      args: SelectSubset<T, ship_marinerUpsertArgs>
    ): CheckSelect<T, Prisma__ship_marinerClient<ship_mariner>, Prisma__ship_marinerClient<ship_marinerGetPayload<T>>>

    /**
     * Count the number of Ship_mariners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_marinerCountArgs} args - Arguments to filter Ship_mariners to count.
     * @example
     * // Count the number of Ship_mariners
     * const count = await prisma.ship_mariner.count({
     *   where: {
     *     // ... the filter for the Ship_mariners we want to count
     *   }
     * })
    **/
    count<T extends ship_marinerCountArgs>(
      args?: Subset<T, ship_marinerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ship_marinerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ship_mariner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ship_marinerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ship_marinerAggregateArgs>(args: Subset<T, Ship_marinerAggregateArgs>): PrismaPromise<GetShip_marinerAggregateType<T>>

    /**
     * Group by Ship_mariner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ship_marinerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ship_marinerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ship_marinerGroupByArgs['orderBy'] }
        : { orderBy?: Ship_marinerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ship_marinerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShip_marinerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ship_mariner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ship_marinerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Mariner<T extends marinerArgs = {}>(args?: Subset<T, marinerArgs>): CheckSelect<T, Prisma__marinerClient<mariner | null >, Prisma__marinerClient<marinerGetPayload<T> | null >>;

    Ship<T extends shipArgs = {}>(args?: Subset<T, shipArgs>): CheckSelect<T, Prisma__shipClient<ship | null >, Prisma__shipClient<shipGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ship_mariner findUnique
   */
  export type ship_marinerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
    /**
     * Throw an Error if a ship_mariner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ship_mariner to fetch.
     * 
    **/
    where: ship_marinerWhereUniqueInput
  }


  /**
   * ship_mariner findFirst
   */
  export type ship_marinerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
    /**
     * Throw an Error if a ship_mariner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ship_mariner to fetch.
     * 
    **/
    where?: ship_marinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ship_mariners to fetch.
     * 
    **/
    orderBy?: Enumerable<ship_marinerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ship_mariners.
     * 
    **/
    cursor?: ship_marinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ship_mariners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ship_mariners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ship_mariners.
     * 
    **/
    distinct?: Enumerable<Ship_marinerScalarFieldEnum>
  }


  /**
   * ship_mariner findMany
   */
  export type ship_marinerFindManyArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
    /**
     * Filter, which ship_mariners to fetch.
     * 
    **/
    where?: ship_marinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ship_mariners to fetch.
     * 
    **/
    orderBy?: Enumerable<ship_marinerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ship_mariners.
     * 
    **/
    cursor?: ship_marinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ship_mariners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ship_mariners.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Ship_marinerScalarFieldEnum>
  }


  /**
   * ship_mariner create
   */
  export type ship_marinerCreateArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
    /**
     * The data needed to create a ship_mariner.
     * 
    **/
    data: XOR<ship_marinerCreateInput, ship_marinerUncheckedCreateInput>
  }


  /**
   * ship_mariner createMany
   */
  export type ship_marinerCreateManyArgs = {
    /**
     * The data used to create many ship_mariners.
     * 
    **/
    data: Enumerable<ship_marinerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ship_mariner update
   */
  export type ship_marinerUpdateArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
    /**
     * The data needed to update a ship_mariner.
     * 
    **/
    data: XOR<ship_marinerUpdateInput, ship_marinerUncheckedUpdateInput>
    /**
     * Choose, which ship_mariner to update.
     * 
    **/
    where: ship_marinerWhereUniqueInput
  }


  /**
   * ship_mariner updateMany
   */
  export type ship_marinerUpdateManyArgs = {
    /**
     * The data used to update ship_mariners.
     * 
    **/
    data: XOR<ship_marinerUpdateManyMutationInput, ship_marinerUncheckedUpdateManyInput>
    /**
     * Filter which ship_mariners to update
     * 
    **/
    where?: ship_marinerWhereInput
  }


  /**
   * ship_mariner upsert
   */
  export type ship_marinerUpsertArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
    /**
     * The filter to search for the ship_mariner to update in case it exists.
     * 
    **/
    where: ship_marinerWhereUniqueInput
    /**
     * In case the ship_mariner found by the `where` argument doesn't exist, create a new ship_mariner with this data.
     * 
    **/
    create: XOR<ship_marinerCreateInput, ship_marinerUncheckedCreateInput>
    /**
     * In case the ship_mariner was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ship_marinerUpdateInput, ship_marinerUncheckedUpdateInput>
  }


  /**
   * ship_mariner delete
   */
  export type ship_marinerDeleteArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
    /**
     * Filter which ship_mariner to delete.
     * 
    **/
    where: ship_marinerWhereUniqueInput
  }


  /**
   * ship_mariner deleteMany
   */
  export type ship_marinerDeleteManyArgs = {
    /**
     * Filter which ship_mariners to delete
     * 
    **/
    where?: ship_marinerWhereInput
  }


  /**
   * ship_mariner without action
   */
  export type ship_marinerArgs = {
    /**
     * Select specific fields to fetch from the ship_mariner
     * 
    **/
    select?: ship_marinerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_marinerInclude | null
  }



  /**
   * Model ship_client
   */


  export type AggregateShip_client = {
    _count: Ship_clientCountAggregateOutputType | null
    _avg: Ship_clientAvgAggregateOutputType | null
    _sum: Ship_clientSumAggregateOutputType | null
    _min: Ship_clientMinAggregateOutputType | null
    _max: Ship_clientMaxAggregateOutputType | null
  }

  export type Ship_clientAvgAggregateOutputType = {
    cd_ship: number | null
    cd_client: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_clientSumAggregateOutputType = {
    cd_ship: number | null
    cd_client: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_clientMinAggregateOutputType = {
    cd_ship: number | null
    cd_client: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_clientMaxAggregateOutputType = {
    cd_ship: number | null
    cd_client: number | null
    id_cliente_mariner: number | null
  }

  export type Ship_clientCountAggregateOutputType = {
    cd_ship: number
    cd_client: number
    id_cliente_mariner: number
    _all: number
  }


  export type Ship_clientAvgAggregateInputType = {
    cd_ship?: true
    cd_client?: true
    id_cliente_mariner?: true
  }

  export type Ship_clientSumAggregateInputType = {
    cd_ship?: true
    cd_client?: true
    id_cliente_mariner?: true
  }

  export type Ship_clientMinAggregateInputType = {
    cd_ship?: true
    cd_client?: true
    id_cliente_mariner?: true
  }

  export type Ship_clientMaxAggregateInputType = {
    cd_ship?: true
    cd_client?: true
    id_cliente_mariner?: true
  }

  export type Ship_clientCountAggregateInputType = {
    cd_ship?: true
    cd_client?: true
    id_cliente_mariner?: true
    _all?: true
  }

  export type Ship_clientAggregateArgs = {
    /**
     * Filter which ship_client to aggregate.
     * 
    **/
    where?: ship_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ship_clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ship_clientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ship_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ship_clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ship_clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ship_clients
    **/
    _count?: true | Ship_clientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ship_clientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ship_clientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ship_clientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ship_clientMaxAggregateInputType
  }

  export type GetShip_clientAggregateType<T extends Ship_clientAggregateArgs> = {
        [P in keyof T & keyof AggregateShip_client]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShip_client[P]>
      : GetScalarType<T[P], AggregateShip_client[P]>
  }




  export type Ship_clientGroupByArgs = {
    where?: ship_clientWhereInput
    orderBy?: Enumerable<ship_clientOrderByWithAggregationInput>
    by: Array<Ship_clientScalarFieldEnum>
    having?: ship_clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ship_clientCountAggregateInputType | true
    _avg?: Ship_clientAvgAggregateInputType
    _sum?: Ship_clientSumAggregateInputType
    _min?: Ship_clientMinAggregateInputType
    _max?: Ship_clientMaxAggregateInputType
  }


  export type Ship_clientGroupByOutputType = {
    cd_ship: number
    cd_client: number
    id_cliente_mariner: number
    _count: Ship_clientCountAggregateOutputType | null
    _avg: Ship_clientAvgAggregateOutputType | null
    _sum: Ship_clientSumAggregateOutputType | null
    _min: Ship_clientMinAggregateOutputType | null
    _max: Ship_clientMaxAggregateOutputType | null
  }

  type GetShip_clientGroupByPayload<T extends Ship_clientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Ship_clientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ship_clientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ship_clientGroupByOutputType[P]>
            : GetScalarType<T[P], Ship_clientGroupByOutputType[P]>
        }
      >
    >


  export type ship_clientSelect = {
    cd_ship?: boolean
    cd_client?: boolean
    id_cliente_mariner?: boolean
    Client?: boolean | clientArgs
    Ship?: boolean | shipArgs
  }

  export type ship_clientInclude = {
    Client?: boolean | clientArgs
    Ship?: boolean | shipArgs
  }

  export type ship_clientGetPayload<
    S extends boolean | null | undefined | ship_clientArgs,
    U = keyof S
      > = S extends true
        ? ship_client
    : S extends undefined
    ? never
    : S extends ship_clientArgs | ship_clientFindManyArgs
    ?'include' extends U
    ? ship_client  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Client' ? clientGetPayload<S['include'][P]> :
        P extends 'Ship' ? shipGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Client' ? clientGetPayload<S['select'][P]> :
        P extends 'Ship' ? shipGetPayload<S['select'][P]> :  P extends keyof ship_client ? ship_client[P] : never
  } 
    : ship_client
  : ship_client


  type ship_clientCountArgs = Merge<
    Omit<ship_clientFindManyArgs, 'select' | 'include'> & {
      select?: Ship_clientCountAggregateInputType | true
    }
  >

  export interface ship_clientDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ship_client that matches the filter.
     * @param {ship_clientFindUniqueArgs} args - Arguments to find a Ship_client
     * @example
     * // Get one Ship_client
     * const ship_client = await prisma.ship_client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ship_clientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ship_clientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ship_client'> extends True ? CheckSelect<T, Prisma__ship_clientClient<ship_client>, Prisma__ship_clientClient<ship_clientGetPayload<T>>> : CheckSelect<T, Prisma__ship_clientClient<ship_client | null >, Prisma__ship_clientClient<ship_clientGetPayload<T> | null >>

    /**
     * Find the first Ship_client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_clientFindFirstArgs} args - Arguments to find a Ship_client
     * @example
     * // Get one Ship_client
     * const ship_client = await prisma.ship_client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ship_clientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ship_clientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ship_client'> extends True ? CheckSelect<T, Prisma__ship_clientClient<ship_client>, Prisma__ship_clientClient<ship_clientGetPayload<T>>> : CheckSelect<T, Prisma__ship_clientClient<ship_client | null >, Prisma__ship_clientClient<ship_clientGetPayload<T> | null >>

    /**
     * Find zero or more Ship_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_clientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ship_clients
     * const ship_clients = await prisma.ship_client.findMany()
     * 
     * // Get first 10 Ship_clients
     * const ship_clients = await prisma.ship_client.findMany({ take: 10 })
     * 
     * // Only select the `cd_ship`
     * const ship_clientWithCd_shipOnly = await prisma.ship_client.findMany({ select: { cd_ship: true } })
     * 
    **/
    findMany<T extends ship_clientFindManyArgs>(
      args?: SelectSubset<T, ship_clientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ship_client>>, PrismaPromise<Array<ship_clientGetPayload<T>>>>

    /**
     * Create a Ship_client.
     * @param {ship_clientCreateArgs} args - Arguments to create a Ship_client.
     * @example
     * // Create one Ship_client
     * const Ship_client = await prisma.ship_client.create({
     *   data: {
     *     // ... data to create a Ship_client
     *   }
     * })
     * 
    **/
    create<T extends ship_clientCreateArgs>(
      args: SelectSubset<T, ship_clientCreateArgs>
    ): CheckSelect<T, Prisma__ship_clientClient<ship_client>, Prisma__ship_clientClient<ship_clientGetPayload<T>>>

    /**
     * Create many Ship_clients.
     *     @param {ship_clientCreateManyArgs} args - Arguments to create many Ship_clients.
     *     @example
     *     // Create many Ship_clients
     *     const ship_client = await prisma.ship_client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ship_clientCreateManyArgs>(
      args?: SelectSubset<T, ship_clientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ship_client.
     * @param {ship_clientDeleteArgs} args - Arguments to delete one Ship_client.
     * @example
     * // Delete one Ship_client
     * const Ship_client = await prisma.ship_client.delete({
     *   where: {
     *     // ... filter to delete one Ship_client
     *   }
     * })
     * 
    **/
    delete<T extends ship_clientDeleteArgs>(
      args: SelectSubset<T, ship_clientDeleteArgs>
    ): CheckSelect<T, Prisma__ship_clientClient<ship_client>, Prisma__ship_clientClient<ship_clientGetPayload<T>>>

    /**
     * Update one Ship_client.
     * @param {ship_clientUpdateArgs} args - Arguments to update one Ship_client.
     * @example
     * // Update one Ship_client
     * const ship_client = await prisma.ship_client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ship_clientUpdateArgs>(
      args: SelectSubset<T, ship_clientUpdateArgs>
    ): CheckSelect<T, Prisma__ship_clientClient<ship_client>, Prisma__ship_clientClient<ship_clientGetPayload<T>>>

    /**
     * Delete zero or more Ship_clients.
     * @param {ship_clientDeleteManyArgs} args - Arguments to filter Ship_clients to delete.
     * @example
     * // Delete a few Ship_clients
     * const { count } = await prisma.ship_client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ship_clientDeleteManyArgs>(
      args?: SelectSubset<T, ship_clientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ship_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ship_clients
     * const ship_client = await prisma.ship_client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ship_clientUpdateManyArgs>(
      args: SelectSubset<T, ship_clientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ship_client.
     * @param {ship_clientUpsertArgs} args - Arguments to update or create a Ship_client.
     * @example
     * // Update or create a Ship_client
     * const ship_client = await prisma.ship_client.upsert({
     *   create: {
     *     // ... data to create a Ship_client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ship_client we want to update
     *   }
     * })
    **/
    upsert<T extends ship_clientUpsertArgs>(
      args: SelectSubset<T, ship_clientUpsertArgs>
    ): CheckSelect<T, Prisma__ship_clientClient<ship_client>, Prisma__ship_clientClient<ship_clientGetPayload<T>>>

    /**
     * Count the number of Ship_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ship_clientCountArgs} args - Arguments to filter Ship_clients to count.
     * @example
     * // Count the number of Ship_clients
     * const count = await prisma.ship_client.count({
     *   where: {
     *     // ... the filter for the Ship_clients we want to count
     *   }
     * })
    **/
    count<T extends ship_clientCountArgs>(
      args?: Subset<T, ship_clientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ship_clientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ship_client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ship_clientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ship_clientAggregateArgs>(args: Subset<T, Ship_clientAggregateArgs>): PrismaPromise<GetShip_clientAggregateType<T>>

    /**
     * Group by Ship_client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ship_clientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ship_clientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ship_clientGroupByArgs['orderBy'] }
        : { orderBy?: Ship_clientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ship_clientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShip_clientGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ship_client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ship_clientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Client<T extends clientArgs = {}>(args?: Subset<T, clientArgs>): CheckSelect<T, Prisma__clientClient<client | null >, Prisma__clientClient<clientGetPayload<T> | null >>;

    Ship<T extends shipArgs = {}>(args?: Subset<T, shipArgs>): CheckSelect<T, Prisma__shipClient<ship | null >, Prisma__shipClient<shipGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ship_client findUnique
   */
  export type ship_clientFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
    /**
     * Throw an Error if a ship_client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ship_client to fetch.
     * 
    **/
    where: ship_clientWhereUniqueInput
  }


  /**
   * ship_client findFirst
   */
  export type ship_clientFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
    /**
     * Throw an Error if a ship_client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ship_client to fetch.
     * 
    **/
    where?: ship_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ship_clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ship_clientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ship_clients.
     * 
    **/
    cursor?: ship_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ship_clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ship_clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ship_clients.
     * 
    **/
    distinct?: Enumerable<Ship_clientScalarFieldEnum>
  }


  /**
   * ship_client findMany
   */
  export type ship_clientFindManyArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
    /**
     * Filter, which ship_clients to fetch.
     * 
    **/
    where?: ship_clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ship_clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ship_clientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ship_clients.
     * 
    **/
    cursor?: ship_clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ship_clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ship_clients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Ship_clientScalarFieldEnum>
  }


  /**
   * ship_client create
   */
  export type ship_clientCreateArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
    /**
     * The data needed to create a ship_client.
     * 
    **/
    data: XOR<ship_clientCreateInput, ship_clientUncheckedCreateInput>
  }


  /**
   * ship_client createMany
   */
  export type ship_clientCreateManyArgs = {
    /**
     * The data used to create many ship_clients.
     * 
    **/
    data: Enumerable<ship_clientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ship_client update
   */
  export type ship_clientUpdateArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
    /**
     * The data needed to update a ship_client.
     * 
    **/
    data: XOR<ship_clientUpdateInput, ship_clientUncheckedUpdateInput>
    /**
     * Choose, which ship_client to update.
     * 
    **/
    where: ship_clientWhereUniqueInput
  }


  /**
   * ship_client updateMany
   */
  export type ship_clientUpdateManyArgs = {
    /**
     * The data used to update ship_clients.
     * 
    **/
    data: XOR<ship_clientUpdateManyMutationInput, ship_clientUncheckedUpdateManyInput>
    /**
     * Filter which ship_clients to update
     * 
    **/
    where?: ship_clientWhereInput
  }


  /**
   * ship_client upsert
   */
  export type ship_clientUpsertArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
    /**
     * The filter to search for the ship_client to update in case it exists.
     * 
    **/
    where: ship_clientWhereUniqueInput
    /**
     * In case the ship_client found by the `where` argument doesn't exist, create a new ship_client with this data.
     * 
    **/
    create: XOR<ship_clientCreateInput, ship_clientUncheckedCreateInput>
    /**
     * In case the ship_client was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ship_clientUpdateInput, ship_clientUncheckedUpdateInput>
  }


  /**
   * ship_client delete
   */
  export type ship_clientDeleteArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
    /**
     * Filter which ship_client to delete.
     * 
    **/
    where: ship_clientWhereUniqueInput
  }


  /**
   * ship_client deleteMany
   */
  export type ship_clientDeleteManyArgs = {
    /**
     * Filter which ship_clients to delete
     * 
    **/
    where?: ship_clientWhereInput
  }


  /**
   * ship_client without action
   */
  export type ship_clientArgs = {
    /**
     * Select specific fields to fetch from the ship_client
     * 
    **/
    select?: ship_clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ship_clientInclude | null
  }



  /**
   * Model movimentation
   */


  export type AggregateMovimentation = {
    _count: MovimentationCountAggregateOutputType | null
    _avg: MovimentationAvgAggregateOutputType | null
    _sum: MovimentationSumAggregateOutputType | null
    _min: MovimentationMinAggregateOutputType | null
    _max: MovimentationMaxAggregateOutputType | null
  }

  export type MovimentationAvgAggregateOutputType = {
    id_movimentation: number | null
    cd_company: number | null
    cd_move_status: number | null
    cd_nav_plan: number | null
  }

  export type MovimentationSumAggregateOutputType = {
    id_movimentation: number | null
    cd_company: number | null
    cd_move_status: number | null
    cd_nav_plan: number | null
  }

  export type MovimentationMinAggregateOutputType = {
    id_movimentation: number | null
    cd_company: number | null
    dt_finished: Date | null
    dt_opned: Date | null
    id_finished: boolean | null
    cd_move_status: number | null
    cd_nav_plan: number | null
  }

  export type MovimentationMaxAggregateOutputType = {
    id_movimentation: number | null
    cd_company: number | null
    dt_finished: Date | null
    dt_opned: Date | null
    id_finished: boolean | null
    cd_move_status: number | null
    cd_nav_plan: number | null
  }

  export type MovimentationCountAggregateOutputType = {
    id_movimentation: number
    cd_company: number
    dt_finished: number
    dt_opned: number
    id_finished: number
    cd_move_status: number
    cd_nav_plan: number
    _all: number
  }


  export type MovimentationAvgAggregateInputType = {
    id_movimentation?: true
    cd_company?: true
    cd_move_status?: true
    cd_nav_plan?: true
  }

  export type MovimentationSumAggregateInputType = {
    id_movimentation?: true
    cd_company?: true
    cd_move_status?: true
    cd_nav_plan?: true
  }

  export type MovimentationMinAggregateInputType = {
    id_movimentation?: true
    cd_company?: true
    dt_finished?: true
    dt_opned?: true
    id_finished?: true
    cd_move_status?: true
    cd_nav_plan?: true
  }

  export type MovimentationMaxAggregateInputType = {
    id_movimentation?: true
    cd_company?: true
    dt_finished?: true
    dt_opned?: true
    id_finished?: true
    cd_move_status?: true
    cd_nav_plan?: true
  }

  export type MovimentationCountAggregateInputType = {
    id_movimentation?: true
    cd_company?: true
    dt_finished?: true
    dt_opned?: true
    id_finished?: true
    cd_move_status?: true
    cd_nav_plan?: true
    _all?: true
  }

  export type MovimentationAggregateArgs = {
    /**
     * Filter which movimentation to aggregate.
     * 
    **/
    where?: movimentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimentations to fetch.
     * 
    **/
    orderBy?: Enumerable<movimentationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: movimentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimentations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimentations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned movimentations
    **/
    _count?: true | MovimentationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovimentationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovimentationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovimentationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovimentationMaxAggregateInputType
  }

  export type GetMovimentationAggregateType<T extends MovimentationAggregateArgs> = {
        [P in keyof T & keyof AggregateMovimentation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovimentation[P]>
      : GetScalarType<T[P], AggregateMovimentation[P]>
  }




  export type MovimentationGroupByArgs = {
    where?: movimentationWhereInput
    orderBy?: Enumerable<movimentationOrderByWithAggregationInput>
    by: Array<MovimentationScalarFieldEnum>
    having?: movimentationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovimentationCountAggregateInputType | true
    _avg?: MovimentationAvgAggregateInputType
    _sum?: MovimentationSumAggregateInputType
    _min?: MovimentationMinAggregateInputType
    _max?: MovimentationMaxAggregateInputType
  }


  export type MovimentationGroupByOutputType = {
    id_movimentation: number
    cd_company: number
    dt_finished: Date | null
    dt_opned: Date
    id_finished: boolean
    cd_move_status: number
    cd_nav_plan: number | null
    _count: MovimentationCountAggregateOutputType | null
    _avg: MovimentationAvgAggregateOutputType | null
    _sum: MovimentationSumAggregateOutputType | null
    _min: MovimentationMinAggregateOutputType | null
    _max: MovimentationMaxAggregateOutputType | null
  }

  type GetMovimentationGroupByPayload<T extends MovimentationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MovimentationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovimentationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovimentationGroupByOutputType[P]>
            : GetScalarType<T[P], MovimentationGroupByOutputType[P]>
        }
      >
    >


  export type movimentationSelect = {
    id_movimentation?: boolean
    cd_company?: boolean
    dt_finished?: boolean
    dt_opned?: boolean
    id_finished?: boolean
    cd_move_status?: boolean
    cd_nav_plan?: boolean
    Company?: boolean | companyArgs
    move_staus?: boolean | move_statusArgs
    navagation_plan?: boolean | navagation_planArgs
  }

  export type movimentationInclude = {
    Company?: boolean | companyArgs
    move_staus?: boolean | move_statusArgs
    navagation_plan?: boolean | navagation_planArgs
  }

  export type movimentationGetPayload<
    S extends boolean | null | undefined | movimentationArgs,
    U = keyof S
      > = S extends true
        ? movimentation
    : S extends undefined
    ? never
    : S extends movimentationArgs | movimentationFindManyArgs
    ?'include' extends U
    ? movimentation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Company' ? companyGetPayload<S['include'][P]> :
        P extends 'move_staus' ? move_statusGetPayload<S['include'][P]> :
        P extends 'navagation_plan' ? navagation_planGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Company' ? companyGetPayload<S['select'][P]> :
        P extends 'move_staus' ? move_statusGetPayload<S['select'][P]> :
        P extends 'navagation_plan' ? navagation_planGetPayload<S['select'][P]> | null :  P extends keyof movimentation ? movimentation[P] : never
  } 
    : movimentation
  : movimentation


  type movimentationCountArgs = Merge<
    Omit<movimentationFindManyArgs, 'select' | 'include'> & {
      select?: MovimentationCountAggregateInputType | true
    }
  >

  export interface movimentationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Movimentation that matches the filter.
     * @param {movimentationFindUniqueArgs} args - Arguments to find a Movimentation
     * @example
     * // Get one Movimentation
     * const movimentation = await prisma.movimentation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends movimentationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, movimentationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'movimentation'> extends True ? CheckSelect<T, Prisma__movimentationClient<movimentation>, Prisma__movimentationClient<movimentationGetPayload<T>>> : CheckSelect<T, Prisma__movimentationClient<movimentation | null >, Prisma__movimentationClient<movimentationGetPayload<T> | null >>

    /**
     * Find the first Movimentation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimentationFindFirstArgs} args - Arguments to find a Movimentation
     * @example
     * // Get one Movimentation
     * const movimentation = await prisma.movimentation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends movimentationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, movimentationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'movimentation'> extends True ? CheckSelect<T, Prisma__movimentationClient<movimentation>, Prisma__movimentationClient<movimentationGetPayload<T>>> : CheckSelect<T, Prisma__movimentationClient<movimentation | null >, Prisma__movimentationClient<movimentationGetPayload<T> | null >>

    /**
     * Find zero or more Movimentations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimentationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movimentations
     * const movimentations = await prisma.movimentation.findMany()
     * 
     * // Get first 10 Movimentations
     * const movimentations = await prisma.movimentation.findMany({ take: 10 })
     * 
     * // Only select the `id_movimentation`
     * const movimentationWithId_movimentationOnly = await prisma.movimentation.findMany({ select: { id_movimentation: true } })
     * 
    **/
    findMany<T extends movimentationFindManyArgs>(
      args?: SelectSubset<T, movimentationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<movimentation>>, PrismaPromise<Array<movimentationGetPayload<T>>>>

    /**
     * Create a Movimentation.
     * @param {movimentationCreateArgs} args - Arguments to create a Movimentation.
     * @example
     * // Create one Movimentation
     * const Movimentation = await prisma.movimentation.create({
     *   data: {
     *     // ... data to create a Movimentation
     *   }
     * })
     * 
    **/
    create<T extends movimentationCreateArgs>(
      args: SelectSubset<T, movimentationCreateArgs>
    ): CheckSelect<T, Prisma__movimentationClient<movimentation>, Prisma__movimentationClient<movimentationGetPayload<T>>>

    /**
     * Create many Movimentations.
     *     @param {movimentationCreateManyArgs} args - Arguments to create many Movimentations.
     *     @example
     *     // Create many Movimentations
     *     const movimentation = await prisma.movimentation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends movimentationCreateManyArgs>(
      args?: SelectSubset<T, movimentationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Movimentation.
     * @param {movimentationDeleteArgs} args - Arguments to delete one Movimentation.
     * @example
     * // Delete one Movimentation
     * const Movimentation = await prisma.movimentation.delete({
     *   where: {
     *     // ... filter to delete one Movimentation
     *   }
     * })
     * 
    **/
    delete<T extends movimentationDeleteArgs>(
      args: SelectSubset<T, movimentationDeleteArgs>
    ): CheckSelect<T, Prisma__movimentationClient<movimentation>, Prisma__movimentationClient<movimentationGetPayload<T>>>

    /**
     * Update one Movimentation.
     * @param {movimentationUpdateArgs} args - Arguments to update one Movimentation.
     * @example
     * // Update one Movimentation
     * const movimentation = await prisma.movimentation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends movimentationUpdateArgs>(
      args: SelectSubset<T, movimentationUpdateArgs>
    ): CheckSelect<T, Prisma__movimentationClient<movimentation>, Prisma__movimentationClient<movimentationGetPayload<T>>>

    /**
     * Delete zero or more Movimentations.
     * @param {movimentationDeleteManyArgs} args - Arguments to filter Movimentations to delete.
     * @example
     * // Delete a few Movimentations
     * const { count } = await prisma.movimentation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends movimentationDeleteManyArgs>(
      args?: SelectSubset<T, movimentationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movimentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimentationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movimentations
     * const movimentation = await prisma.movimentation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends movimentationUpdateManyArgs>(
      args: SelectSubset<T, movimentationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Movimentation.
     * @param {movimentationUpsertArgs} args - Arguments to update or create a Movimentation.
     * @example
     * // Update or create a Movimentation
     * const movimentation = await prisma.movimentation.upsert({
     *   create: {
     *     // ... data to create a Movimentation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movimentation we want to update
     *   }
     * })
    **/
    upsert<T extends movimentationUpsertArgs>(
      args: SelectSubset<T, movimentationUpsertArgs>
    ): CheckSelect<T, Prisma__movimentationClient<movimentation>, Prisma__movimentationClient<movimentationGetPayload<T>>>

    /**
     * Count the number of Movimentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimentationCountArgs} args - Arguments to filter Movimentations to count.
     * @example
     * // Count the number of Movimentations
     * const count = await prisma.movimentation.count({
     *   where: {
     *     // ... the filter for the Movimentations we want to count
     *   }
     * })
    **/
    count<T extends movimentationCountArgs>(
      args?: Subset<T, movimentationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovimentationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movimentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimentationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovimentationAggregateArgs>(args: Subset<T, MovimentationAggregateArgs>): PrismaPromise<GetMovimentationAggregateType<T>>

    /**
     * Group by Movimentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimentationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovimentationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovimentationGroupByArgs['orderBy'] }
        : { orderBy?: MovimentationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovimentationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovimentationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for movimentation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__movimentationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>;

    move_staus<T extends move_statusArgs = {}>(args?: Subset<T, move_statusArgs>): CheckSelect<T, Prisma__move_statusClient<move_status | null >, Prisma__move_statusClient<move_statusGetPayload<T> | null >>;

    navagation_plan<T extends navagation_planArgs = {}>(args?: Subset<T, navagation_planArgs>): CheckSelect<T, Prisma__navagation_planClient<navagation_plan | null >, Prisma__navagation_planClient<navagation_planGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * movimentation findUnique
   */
  export type movimentationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
    /**
     * Throw an Error if a movimentation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which movimentation to fetch.
     * 
    **/
    where: movimentationWhereUniqueInput
  }


  /**
   * movimentation findFirst
   */
  export type movimentationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
    /**
     * Throw an Error if a movimentation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which movimentation to fetch.
     * 
    **/
    where?: movimentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimentations to fetch.
     * 
    **/
    orderBy?: Enumerable<movimentationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movimentations.
     * 
    **/
    cursor?: movimentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimentations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimentations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movimentations.
     * 
    **/
    distinct?: Enumerable<MovimentationScalarFieldEnum>
  }


  /**
   * movimentation findMany
   */
  export type movimentationFindManyArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
    /**
     * Filter, which movimentations to fetch.
     * 
    **/
    where?: movimentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimentations to fetch.
     * 
    **/
    orderBy?: Enumerable<movimentationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing movimentations.
     * 
    **/
    cursor?: movimentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimentations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimentations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MovimentationScalarFieldEnum>
  }


  /**
   * movimentation create
   */
  export type movimentationCreateArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
    /**
     * The data needed to create a movimentation.
     * 
    **/
    data: XOR<movimentationCreateInput, movimentationUncheckedCreateInput>
  }


  /**
   * movimentation createMany
   */
  export type movimentationCreateManyArgs = {
    /**
     * The data used to create many movimentations.
     * 
    **/
    data: Enumerable<movimentationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * movimentation update
   */
  export type movimentationUpdateArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
    /**
     * The data needed to update a movimentation.
     * 
    **/
    data: XOR<movimentationUpdateInput, movimentationUncheckedUpdateInput>
    /**
     * Choose, which movimentation to update.
     * 
    **/
    where: movimentationWhereUniqueInput
  }


  /**
   * movimentation updateMany
   */
  export type movimentationUpdateManyArgs = {
    /**
     * The data used to update movimentations.
     * 
    **/
    data: XOR<movimentationUpdateManyMutationInput, movimentationUncheckedUpdateManyInput>
    /**
     * Filter which movimentations to update
     * 
    **/
    where?: movimentationWhereInput
  }


  /**
   * movimentation upsert
   */
  export type movimentationUpsertArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
    /**
     * The filter to search for the movimentation to update in case it exists.
     * 
    **/
    where: movimentationWhereUniqueInput
    /**
     * In case the movimentation found by the `where` argument doesn't exist, create a new movimentation with this data.
     * 
    **/
    create: XOR<movimentationCreateInput, movimentationUncheckedCreateInput>
    /**
     * In case the movimentation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<movimentationUpdateInput, movimentationUncheckedUpdateInput>
  }


  /**
   * movimentation delete
   */
  export type movimentationDeleteArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
    /**
     * Filter which movimentation to delete.
     * 
    **/
    where: movimentationWhereUniqueInput
  }


  /**
   * movimentation deleteMany
   */
  export type movimentationDeleteManyArgs = {
    /**
     * Filter which movimentations to delete
     * 
    **/
    where?: movimentationWhereInput
  }


  /**
   * movimentation without action
   */
  export type movimentationArgs = {
    /**
     * Select specific fields to fetch from the movimentation
     * 
    **/
    select?: movimentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: movimentationInclude | null
  }



  /**
   * Model navagation_plan
   */


  export type AggregateNavagation_plan = {
    _count: Navagation_planCountAggregateOutputType | null
    _avg: Navagation_planAvgAggregateOutputType | null
    _sum: Navagation_planSumAggregateOutputType | null
    _min: Navagation_planMinAggregateOutputType | null
    _max: Navagation_planMaxAggregateOutputType | null
  }

  export type Navagation_planAvgAggregateOutputType = {
    qt_crew: number | null
    qt_passengers: number | null
    cd_destiny: number | null
    cd_user: number | null
    cd_company: number | null
    cd_move_status: number | null
    id_nav_plan: number | null
  }

  export type Navagation_planSumAggregateOutputType = {
    qt_crew: number | null
    qt_passengers: number | null
    cd_destiny: number | null
    cd_user: number | null
    cd_company: number | null
    cd_move_status: number | null
    id_nav_plan: number | null
  }

  export type Navagation_planMinAggregateOutputType = {
    qt_crew: number | null
    qt_passengers: number | null
    dt_departure: Date | null
    dt_arrival: Date | null
    ds_observation: string | null
    cd_destiny: number | null
    cd_user: number | null
    cd_company: number | null
    cd_move_status: number | null
    id_nav_plan: number | null
  }

  export type Navagation_planMaxAggregateOutputType = {
    qt_crew: number | null
    qt_passengers: number | null
    dt_departure: Date | null
    dt_arrival: Date | null
    ds_observation: string | null
    cd_destiny: number | null
    cd_user: number | null
    cd_company: number | null
    cd_move_status: number | null
    id_nav_plan: number | null
  }

  export type Navagation_planCountAggregateOutputType = {
    qt_crew: number
    qt_passengers: number
    dt_departure: number
    dt_arrival: number
    ds_observation: number
    cd_destiny: number
    cd_user: number
    cd_company: number
    cd_move_status: number
    id_nav_plan: number
    _all: number
  }


  export type Navagation_planAvgAggregateInputType = {
    qt_crew?: true
    qt_passengers?: true
    cd_destiny?: true
    cd_user?: true
    cd_company?: true
    cd_move_status?: true
    id_nav_plan?: true
  }

  export type Navagation_planSumAggregateInputType = {
    qt_crew?: true
    qt_passengers?: true
    cd_destiny?: true
    cd_user?: true
    cd_company?: true
    cd_move_status?: true
    id_nav_plan?: true
  }

  export type Navagation_planMinAggregateInputType = {
    qt_crew?: true
    qt_passengers?: true
    dt_departure?: true
    dt_arrival?: true
    ds_observation?: true
    cd_destiny?: true
    cd_user?: true
    cd_company?: true
    cd_move_status?: true
    id_nav_plan?: true
  }

  export type Navagation_planMaxAggregateInputType = {
    qt_crew?: true
    qt_passengers?: true
    dt_departure?: true
    dt_arrival?: true
    ds_observation?: true
    cd_destiny?: true
    cd_user?: true
    cd_company?: true
    cd_move_status?: true
    id_nav_plan?: true
  }

  export type Navagation_planCountAggregateInputType = {
    qt_crew?: true
    qt_passengers?: true
    dt_departure?: true
    dt_arrival?: true
    ds_observation?: true
    cd_destiny?: true
    cd_user?: true
    cd_company?: true
    cd_move_status?: true
    id_nav_plan?: true
    _all?: true
  }

  export type Navagation_planAggregateArgs = {
    /**
     * Filter which navagation_plan to aggregate.
     * 
    **/
    where?: navagation_planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of navagation_plans to fetch.
     * 
    **/
    orderBy?: Enumerable<navagation_planOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: navagation_planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` navagation_plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` navagation_plans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned navagation_plans
    **/
    _count?: true | Navagation_planCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Navagation_planAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Navagation_planSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Navagation_planMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Navagation_planMaxAggregateInputType
  }

  export type GetNavagation_planAggregateType<T extends Navagation_planAggregateArgs> = {
        [P in keyof T & keyof AggregateNavagation_plan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavagation_plan[P]>
      : GetScalarType<T[P], AggregateNavagation_plan[P]>
  }




  export type Navagation_planGroupByArgs = {
    where?: navagation_planWhereInput
    orderBy?: Enumerable<navagation_planOrderByWithAggregationInput>
    by: Array<Navagation_planScalarFieldEnum>
    having?: navagation_planScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Navagation_planCountAggregateInputType | true
    _avg?: Navagation_planAvgAggregateInputType
    _sum?: Navagation_planSumAggregateInputType
    _min?: Navagation_planMinAggregateInputType
    _max?: Navagation_planMaxAggregateInputType
  }


  export type Navagation_planGroupByOutputType = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date
    dt_arrival: Date | null
    ds_observation: string | null
    cd_destiny: number
    cd_user: number
    cd_company: number
    cd_move_status: number
    id_nav_plan: number
    _count: Navagation_planCountAggregateOutputType | null
    _avg: Navagation_planAvgAggregateOutputType | null
    _sum: Navagation_planSumAggregateOutputType | null
    _min: Navagation_planMinAggregateOutputType | null
    _max: Navagation_planMaxAggregateOutputType | null
  }

  type GetNavagation_planGroupByPayload<T extends Navagation_planGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Navagation_planGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Navagation_planGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Navagation_planGroupByOutputType[P]>
            : GetScalarType<T[P], Navagation_planGroupByOutputType[P]>
        }
      >
    >


  export type navagation_planSelect = {
    qt_crew?: boolean
    qt_passengers?: boolean
    dt_departure?: boolean
    dt_arrival?: boolean
    ds_observation?: boolean
    cd_destiny?: boolean
    cd_user?: boolean
    cd_company?: boolean
    cd_move_status?: boolean
    id_nav_plan?: boolean
    Company?: boolean | companyArgs
    Location?: boolean | locationArgs
    MoveStaus?: boolean | move_statusArgs
    User?: boolean | usersArgs
    movimentation?: boolean | movimentationFindManyArgs
    _count?: boolean | Navagation_planCountOutputTypeArgs
  }

  export type navagation_planInclude = {
    Company?: boolean | companyArgs
    Location?: boolean | locationArgs
    MoveStaus?: boolean | move_statusArgs
    User?: boolean | usersArgs
    movimentation?: boolean | movimentationFindManyArgs
    _count?: boolean | Navagation_planCountOutputTypeArgs
  }

  export type navagation_planGetPayload<
    S extends boolean | null | undefined | navagation_planArgs,
    U = keyof S
      > = S extends true
        ? navagation_plan
    : S extends undefined
    ? never
    : S extends navagation_planArgs | navagation_planFindManyArgs
    ?'include' extends U
    ? navagation_plan  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Company' ? companyGetPayload<S['include'][P]> :
        P extends 'Location' ? locationGetPayload<S['include'][P]> :
        P extends 'MoveStaus' ? move_statusGetPayload<S['include'][P]> :
        P extends 'User' ? usersGetPayload<S['include'][P]> :
        P extends 'movimentation' ? Array < movimentationGetPayload<S['include'][P]>>  :
        P extends '_count' ? Navagation_planCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Company' ? companyGetPayload<S['select'][P]> :
        P extends 'Location' ? locationGetPayload<S['select'][P]> :
        P extends 'MoveStaus' ? move_statusGetPayload<S['select'][P]> :
        P extends 'User' ? usersGetPayload<S['select'][P]> :
        P extends 'movimentation' ? Array < movimentationGetPayload<S['select'][P]>>  :
        P extends '_count' ? Navagation_planCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof navagation_plan ? navagation_plan[P] : never
  } 
    : navagation_plan
  : navagation_plan


  type navagation_planCountArgs = Merge<
    Omit<navagation_planFindManyArgs, 'select' | 'include'> & {
      select?: Navagation_planCountAggregateInputType | true
    }
  >

  export interface navagation_planDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Navagation_plan that matches the filter.
     * @param {navagation_planFindUniqueArgs} args - Arguments to find a Navagation_plan
     * @example
     * // Get one Navagation_plan
     * const navagation_plan = await prisma.navagation_plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends navagation_planFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, navagation_planFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'navagation_plan'> extends True ? CheckSelect<T, Prisma__navagation_planClient<navagation_plan>, Prisma__navagation_planClient<navagation_planGetPayload<T>>> : CheckSelect<T, Prisma__navagation_planClient<navagation_plan | null >, Prisma__navagation_planClient<navagation_planGetPayload<T> | null >>

    /**
     * Find the first Navagation_plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {navagation_planFindFirstArgs} args - Arguments to find a Navagation_plan
     * @example
     * // Get one Navagation_plan
     * const navagation_plan = await prisma.navagation_plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends navagation_planFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, navagation_planFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'navagation_plan'> extends True ? CheckSelect<T, Prisma__navagation_planClient<navagation_plan>, Prisma__navagation_planClient<navagation_planGetPayload<T>>> : CheckSelect<T, Prisma__navagation_planClient<navagation_plan | null >, Prisma__navagation_planClient<navagation_planGetPayload<T> | null >>

    /**
     * Find zero or more Navagation_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {navagation_planFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Navagation_plans
     * const navagation_plans = await prisma.navagation_plan.findMany()
     * 
     * // Get first 10 Navagation_plans
     * const navagation_plans = await prisma.navagation_plan.findMany({ take: 10 })
     * 
     * // Only select the `qt_crew`
     * const navagation_planWithQt_crewOnly = await prisma.navagation_plan.findMany({ select: { qt_crew: true } })
     * 
    **/
    findMany<T extends navagation_planFindManyArgs>(
      args?: SelectSubset<T, navagation_planFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<navagation_plan>>, PrismaPromise<Array<navagation_planGetPayload<T>>>>

    /**
     * Create a Navagation_plan.
     * @param {navagation_planCreateArgs} args - Arguments to create a Navagation_plan.
     * @example
     * // Create one Navagation_plan
     * const Navagation_plan = await prisma.navagation_plan.create({
     *   data: {
     *     // ... data to create a Navagation_plan
     *   }
     * })
     * 
    **/
    create<T extends navagation_planCreateArgs>(
      args: SelectSubset<T, navagation_planCreateArgs>
    ): CheckSelect<T, Prisma__navagation_planClient<navagation_plan>, Prisma__navagation_planClient<navagation_planGetPayload<T>>>

    /**
     * Create many Navagation_plans.
     *     @param {navagation_planCreateManyArgs} args - Arguments to create many Navagation_plans.
     *     @example
     *     // Create many Navagation_plans
     *     const navagation_plan = await prisma.navagation_plan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends navagation_planCreateManyArgs>(
      args?: SelectSubset<T, navagation_planCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Navagation_plan.
     * @param {navagation_planDeleteArgs} args - Arguments to delete one Navagation_plan.
     * @example
     * // Delete one Navagation_plan
     * const Navagation_plan = await prisma.navagation_plan.delete({
     *   where: {
     *     // ... filter to delete one Navagation_plan
     *   }
     * })
     * 
    **/
    delete<T extends navagation_planDeleteArgs>(
      args: SelectSubset<T, navagation_planDeleteArgs>
    ): CheckSelect<T, Prisma__navagation_planClient<navagation_plan>, Prisma__navagation_planClient<navagation_planGetPayload<T>>>

    /**
     * Update one Navagation_plan.
     * @param {navagation_planUpdateArgs} args - Arguments to update one Navagation_plan.
     * @example
     * // Update one Navagation_plan
     * const navagation_plan = await prisma.navagation_plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends navagation_planUpdateArgs>(
      args: SelectSubset<T, navagation_planUpdateArgs>
    ): CheckSelect<T, Prisma__navagation_planClient<navagation_plan>, Prisma__navagation_planClient<navagation_planGetPayload<T>>>

    /**
     * Delete zero or more Navagation_plans.
     * @param {navagation_planDeleteManyArgs} args - Arguments to filter Navagation_plans to delete.
     * @example
     * // Delete a few Navagation_plans
     * const { count } = await prisma.navagation_plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends navagation_planDeleteManyArgs>(
      args?: SelectSubset<T, navagation_planDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Navagation_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {navagation_planUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Navagation_plans
     * const navagation_plan = await prisma.navagation_plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends navagation_planUpdateManyArgs>(
      args: SelectSubset<T, navagation_planUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Navagation_plan.
     * @param {navagation_planUpsertArgs} args - Arguments to update or create a Navagation_plan.
     * @example
     * // Update or create a Navagation_plan
     * const navagation_plan = await prisma.navagation_plan.upsert({
     *   create: {
     *     // ... data to create a Navagation_plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Navagation_plan we want to update
     *   }
     * })
    **/
    upsert<T extends navagation_planUpsertArgs>(
      args: SelectSubset<T, navagation_planUpsertArgs>
    ): CheckSelect<T, Prisma__navagation_planClient<navagation_plan>, Prisma__navagation_planClient<navagation_planGetPayload<T>>>

    /**
     * Count the number of Navagation_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {navagation_planCountArgs} args - Arguments to filter Navagation_plans to count.
     * @example
     * // Count the number of Navagation_plans
     * const count = await prisma.navagation_plan.count({
     *   where: {
     *     // ... the filter for the Navagation_plans we want to count
     *   }
     * })
    **/
    count<T extends navagation_planCountArgs>(
      args?: Subset<T, navagation_planCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Navagation_planCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Navagation_plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Navagation_planAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Navagation_planAggregateArgs>(args: Subset<T, Navagation_planAggregateArgs>): PrismaPromise<GetNavagation_planAggregateType<T>>

    /**
     * Group by Navagation_plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Navagation_planGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Navagation_planGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Navagation_planGroupByArgs['orderBy'] }
        : { orderBy?: Navagation_planGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Navagation_planGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavagation_planGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for navagation_plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__navagation_planClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null >, Prisma__companyClient<companyGetPayload<T> | null >>;

    Location<T extends locationArgs = {}>(args?: Subset<T, locationArgs>): CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>;

    MoveStaus<T extends move_statusArgs = {}>(args?: Subset<T, move_statusArgs>): CheckSelect<T, Prisma__move_statusClient<move_status | null >, Prisma__move_statusClient<move_statusGetPayload<T> | null >>;

    User<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    movimentation<T extends movimentationFindManyArgs = {}>(args?: Subset<T, movimentationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<movimentation>>, PrismaPromise<Array<movimentationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * navagation_plan findUnique
   */
  export type navagation_planFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
    /**
     * Throw an Error if a navagation_plan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which navagation_plan to fetch.
     * 
    **/
    where: navagation_planWhereUniqueInput
  }


  /**
   * navagation_plan findFirst
   */
  export type navagation_planFindFirstArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
    /**
     * Throw an Error if a navagation_plan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which navagation_plan to fetch.
     * 
    **/
    where?: navagation_planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of navagation_plans to fetch.
     * 
    **/
    orderBy?: Enumerable<navagation_planOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for navagation_plans.
     * 
    **/
    cursor?: navagation_planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` navagation_plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` navagation_plans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of navagation_plans.
     * 
    **/
    distinct?: Enumerable<Navagation_planScalarFieldEnum>
  }


  /**
   * navagation_plan findMany
   */
  export type navagation_planFindManyArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
    /**
     * Filter, which navagation_plans to fetch.
     * 
    **/
    where?: navagation_planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of navagation_plans to fetch.
     * 
    **/
    orderBy?: Enumerable<navagation_planOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing navagation_plans.
     * 
    **/
    cursor?: navagation_planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` navagation_plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` navagation_plans.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Navagation_planScalarFieldEnum>
  }


  /**
   * navagation_plan create
   */
  export type navagation_planCreateArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
    /**
     * The data needed to create a navagation_plan.
     * 
    **/
    data: XOR<navagation_planCreateInput, navagation_planUncheckedCreateInput>
  }


  /**
   * navagation_plan createMany
   */
  export type navagation_planCreateManyArgs = {
    /**
     * The data used to create many navagation_plans.
     * 
    **/
    data: Enumerable<navagation_planCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * navagation_plan update
   */
  export type navagation_planUpdateArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
    /**
     * The data needed to update a navagation_plan.
     * 
    **/
    data: XOR<navagation_planUpdateInput, navagation_planUncheckedUpdateInput>
    /**
     * Choose, which navagation_plan to update.
     * 
    **/
    where: navagation_planWhereUniqueInput
  }


  /**
   * navagation_plan updateMany
   */
  export type navagation_planUpdateManyArgs = {
    /**
     * The data used to update navagation_plans.
     * 
    **/
    data: XOR<navagation_planUpdateManyMutationInput, navagation_planUncheckedUpdateManyInput>
    /**
     * Filter which navagation_plans to update
     * 
    **/
    where?: navagation_planWhereInput
  }


  /**
   * navagation_plan upsert
   */
  export type navagation_planUpsertArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
    /**
     * The filter to search for the navagation_plan to update in case it exists.
     * 
    **/
    where: navagation_planWhereUniqueInput
    /**
     * In case the navagation_plan found by the `where` argument doesn't exist, create a new navagation_plan with this data.
     * 
    **/
    create: XOR<navagation_planCreateInput, navagation_planUncheckedCreateInput>
    /**
     * In case the navagation_plan was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<navagation_planUpdateInput, navagation_planUncheckedUpdateInput>
  }


  /**
   * navagation_plan delete
   */
  export type navagation_planDeleteArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
    /**
     * Filter which navagation_plan to delete.
     * 
    **/
    where: navagation_planWhereUniqueInput
  }


  /**
   * navagation_plan deleteMany
   */
  export type navagation_planDeleteManyArgs = {
    /**
     * Filter which navagation_plans to delete
     * 
    **/
    where?: navagation_planWhereInput
  }


  /**
   * navagation_plan without action
   */
  export type navagation_planArgs = {
    /**
     * Select specific fields to fetch from the navagation_plan
     * 
    **/
    select?: navagation_planSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: navagation_planInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UsersScalarFieldEnum: {
    id_user: 'id_user',
    cd_company: 'cd_company',
    ds_email: 'ds_email',
    ds_name: 'ds_name',
    ds_password: 'ds_password',
    id_manager: 'id_manager',
    id_operational: 'id_operational',
    id_operator: 'id_operator'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id_company: 'id_company',
    ds_cnpj: 'ds_cnpj',
    ds_name: 'ds_name'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id_location: 'id_location',
    ds_location: 'ds_location',
    cd_company: 'cd_company'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const Move_statusScalarFieldEnum: {
    id_status: 'id_status',
    ds_status: 'ds_status'
  };

  export type Move_statusScalarFieldEnum = (typeof Move_statusScalarFieldEnum)[keyof typeof Move_statusScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id_client: 'id_client',
    ds_name: 'ds_name',
    ds_cpf: 'ds_cpf',
    cd_company: 'cd_company'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const MarinerScalarFieldEnum: {
    id_mariner: 'id_mariner',
    ds_name: 'ds_name',
    ds_cpf: 'ds_cpf',
    cd_company: 'cd_company'
  };

  export type MarinerScalarFieldEnum = (typeof MarinerScalarFieldEnum)[keyof typeof MarinerScalarFieldEnum]


  export const ShipScalarFieldEnum: {
    id_ship: 'id_ship',
    ds_ship: 'ds_ship',
    cd_company: 'cd_company'
  };

  export type ShipScalarFieldEnum = (typeof ShipScalarFieldEnum)[keyof typeof ShipScalarFieldEnum]


  export const Ship_marinerScalarFieldEnum: {
    cd_ship: 'cd_ship',
    cd_mariner: 'cd_mariner',
    id_cliente_mariner: 'id_cliente_mariner'
  };

  export type Ship_marinerScalarFieldEnum = (typeof Ship_marinerScalarFieldEnum)[keyof typeof Ship_marinerScalarFieldEnum]


  export const Ship_clientScalarFieldEnum: {
    cd_ship: 'cd_ship',
    cd_client: 'cd_client',
    id_cliente_mariner: 'id_cliente_mariner'
  };

  export type Ship_clientScalarFieldEnum = (typeof Ship_clientScalarFieldEnum)[keyof typeof Ship_clientScalarFieldEnum]


  export const MovimentationScalarFieldEnum: {
    id_movimentation: 'id_movimentation',
    cd_company: 'cd_company',
    dt_finished: 'dt_finished',
    dt_opned: 'dt_opned',
    id_finished: 'id_finished',
    cd_move_status: 'cd_move_status',
    cd_nav_plan: 'cd_nav_plan'
  };

  export type MovimentationScalarFieldEnum = (typeof MovimentationScalarFieldEnum)[keyof typeof MovimentationScalarFieldEnum]


  export const Navagation_planScalarFieldEnum: {
    qt_crew: 'qt_crew',
    qt_passengers: 'qt_passengers',
    dt_departure: 'dt_departure',
    dt_arrival: 'dt_arrival',
    ds_observation: 'ds_observation',
    cd_destiny: 'cd_destiny',
    cd_user: 'cd_user',
    cd_company: 'cd_company',
    cd_move_status: 'cd_move_status',
    id_nav_plan: 'id_nav_plan'
  };

  export type Navagation_planScalarFieldEnum = (typeof Navagation_planScalarFieldEnum)[keyof typeof Navagation_planScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id_user?: IntFilter | number
    cd_company?: IntFilter | number
    ds_email?: StringFilter | string
    ds_name?: StringFilter | string
    ds_password?: StringFilter | string
    id_manager?: BoolFilter | boolean
    id_operational?: BoolFilter | boolean
    id_operator?: BoolFilter | boolean
    Company?: XOR<CompanyRelationFilter, companyWhereInput>
    navagation_plan?: Navagation_planListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id_user?: SortOrder
    cd_company?: SortOrder
    ds_email?: SortOrder
    ds_name?: SortOrder
    ds_password?: SortOrder
    id_manager?: SortOrder
    id_operational?: SortOrder
    id_operator?: SortOrder
    Company?: companyOrderByWithRelationInput
    navagation_plan?: navagation_planOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id_user?: number
  }

  export type usersOrderByWithAggregationInput = {
    id_user?: SortOrder
    cd_company?: SortOrder
    ds_email?: SortOrder
    ds_name?: SortOrder
    ds_password?: SortOrder
    id_manager?: SortOrder
    id_operational?: SortOrder
    id_operator?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id_user?: IntWithAggregatesFilter | number
    cd_company?: IntWithAggregatesFilter | number
    ds_email?: StringWithAggregatesFilter | string
    ds_name?: StringWithAggregatesFilter | string
    ds_password?: StringWithAggregatesFilter | string
    id_manager?: BoolWithAggregatesFilter | boolean
    id_operational?: BoolWithAggregatesFilter | boolean
    id_operator?: BoolWithAggregatesFilter | boolean
  }

  export type companyWhereInput = {
    AND?: Enumerable<companyWhereInput>
    OR?: Enumerable<companyWhereInput>
    NOT?: Enumerable<companyWhereInput>
    id_company?: IntFilter | number
    ds_cnpj?: StringFilter | string
    ds_name?: StringFilter | string
    client?: ClientListRelationFilter
    location?: LocationListRelationFilter
    mariner?: MarinerListRelationFilter
    movimentation?: MovimentationListRelationFilter
    navagation_plan?: Navagation_planListRelationFilter
    ship?: ShipListRelationFilter
    users?: UsersListRelationFilter
  }

  export type companyOrderByWithRelationInput = {
    id_company?: SortOrder
    ds_cnpj?: SortOrder
    ds_name?: SortOrder
    client?: clientOrderByRelationAggregateInput
    location?: locationOrderByRelationAggregateInput
    mariner?: marinerOrderByRelationAggregateInput
    movimentation?: movimentationOrderByRelationAggregateInput
    navagation_plan?: navagation_planOrderByRelationAggregateInput
    ship?: shipOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type companyWhereUniqueInput = {
    id_company?: number
  }

  export type companyOrderByWithAggregationInput = {
    id_company?: SortOrder
    ds_cnpj?: SortOrder
    ds_name?: SortOrder
    _count?: companyCountOrderByAggregateInput
    _avg?: companyAvgOrderByAggregateInput
    _max?: companyMaxOrderByAggregateInput
    _min?: companyMinOrderByAggregateInput
    _sum?: companySumOrderByAggregateInput
  }

  export type companyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companyScalarWhereWithAggregatesInput>
    OR?: Enumerable<companyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companyScalarWhereWithAggregatesInput>
    id_company?: IntWithAggregatesFilter | number
    ds_cnpj?: StringWithAggregatesFilter | string
    ds_name?: StringWithAggregatesFilter | string
  }

  export type locationWhereInput = {
    AND?: Enumerable<locationWhereInput>
    OR?: Enumerable<locationWhereInput>
    NOT?: Enumerable<locationWhereInput>
    id_location?: IntFilter | number
    ds_location?: StringFilter | string
    cd_company?: IntFilter | number
    Company?: XOR<CompanyRelationFilter, companyWhereInput>
    navagation_plan?: Navagation_planListRelationFilter
  }

  export type locationOrderByWithRelationInput = {
    id_location?: SortOrder
    ds_location?: SortOrder
    cd_company?: SortOrder
    Company?: companyOrderByWithRelationInput
    navagation_plan?: navagation_planOrderByRelationAggregateInput
  }

  export type locationWhereUniqueInput = {
    id_location?: number
  }

  export type locationOrderByWithAggregationInput = {
    id_location?: SortOrder
    ds_location?: SortOrder
    cd_company?: SortOrder
    _count?: locationCountOrderByAggregateInput
    _avg?: locationAvgOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
    _sum?: locationSumOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<locationScalarWhereWithAggregatesInput>
    OR?: Enumerable<locationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<locationScalarWhereWithAggregatesInput>
    id_location?: IntWithAggregatesFilter | number
    ds_location?: StringWithAggregatesFilter | string
    cd_company?: IntWithAggregatesFilter | number
  }

  export type move_statusWhereInput = {
    AND?: Enumerable<move_statusWhereInput>
    OR?: Enumerable<move_statusWhereInput>
    NOT?: Enumerable<move_statusWhereInput>
    id_status?: IntFilter | number
    ds_status?: StringFilter | string
    movimentation?: MovimentationListRelationFilter
    navagation_plan?: Navagation_planListRelationFilter
  }

  export type move_statusOrderByWithRelationInput = {
    id_status?: SortOrder
    ds_status?: SortOrder
    movimentation?: movimentationOrderByRelationAggregateInput
    navagation_plan?: navagation_planOrderByRelationAggregateInput
  }

  export type move_statusWhereUniqueInput = {
    id_status?: number
  }

  export type move_statusOrderByWithAggregationInput = {
    id_status?: SortOrder
    ds_status?: SortOrder
    _count?: move_statusCountOrderByAggregateInput
    _avg?: move_statusAvgOrderByAggregateInput
    _max?: move_statusMaxOrderByAggregateInput
    _min?: move_statusMinOrderByAggregateInput
    _sum?: move_statusSumOrderByAggregateInput
  }

  export type move_statusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<move_statusScalarWhereWithAggregatesInput>
    OR?: Enumerable<move_statusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<move_statusScalarWhereWithAggregatesInput>
    id_status?: IntWithAggregatesFilter | number
    ds_status?: StringWithAggregatesFilter | string
  }

  export type clientWhereInput = {
    AND?: Enumerable<clientWhereInput>
    OR?: Enumerable<clientWhereInput>
    NOT?: Enumerable<clientWhereInput>
    id_client?: IntFilter | number
    ds_name?: StringFilter | string
    ds_cpf?: StringFilter | string
    cd_company?: IntFilter | number
    Company?: XOR<CompanyRelationFilter, companyWhereInput>
    ship_client?: Ship_clientListRelationFilter
  }

  export type clientOrderByWithRelationInput = {
    id_client?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
    Company?: companyOrderByWithRelationInput
    ship_client?: ship_clientOrderByRelationAggregateInput
  }

  export type clientWhereUniqueInput = {
    id_client?: number
  }

  export type clientOrderByWithAggregationInput = {
    id_client?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
    _count?: clientCountOrderByAggregateInput
    _avg?: clientAvgOrderByAggregateInput
    _max?: clientMaxOrderByAggregateInput
    _min?: clientMinOrderByAggregateInput
    _sum?: clientSumOrderByAggregateInput
  }

  export type clientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clientScalarWhereWithAggregatesInput>
    OR?: Enumerable<clientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clientScalarWhereWithAggregatesInput>
    id_client?: IntWithAggregatesFilter | number
    ds_name?: StringWithAggregatesFilter | string
    ds_cpf?: StringWithAggregatesFilter | string
    cd_company?: IntWithAggregatesFilter | number
  }

  export type marinerWhereInput = {
    AND?: Enumerable<marinerWhereInput>
    OR?: Enumerable<marinerWhereInput>
    NOT?: Enumerable<marinerWhereInput>
    id_mariner?: IntFilter | number
    ds_name?: StringFilter | string
    ds_cpf?: StringFilter | string
    cd_company?: IntFilter | number
    Company?: XOR<CompanyRelationFilter, companyWhereInput>
    ship_mariner?: Ship_marinerListRelationFilter
  }

  export type marinerOrderByWithRelationInput = {
    id_mariner?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
    Company?: companyOrderByWithRelationInput
    ship_mariner?: ship_marinerOrderByRelationAggregateInput
  }

  export type marinerWhereUniqueInput = {
    id_mariner?: number
  }

  export type marinerOrderByWithAggregationInput = {
    id_mariner?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
    _count?: marinerCountOrderByAggregateInput
    _avg?: marinerAvgOrderByAggregateInput
    _max?: marinerMaxOrderByAggregateInput
    _min?: marinerMinOrderByAggregateInput
    _sum?: marinerSumOrderByAggregateInput
  }

  export type marinerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<marinerScalarWhereWithAggregatesInput>
    OR?: Enumerable<marinerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<marinerScalarWhereWithAggregatesInput>
    id_mariner?: IntWithAggregatesFilter | number
    ds_name?: StringWithAggregatesFilter | string
    ds_cpf?: StringWithAggregatesFilter | string
    cd_company?: IntWithAggregatesFilter | number
  }

  export type shipWhereInput = {
    AND?: Enumerable<shipWhereInput>
    OR?: Enumerable<shipWhereInput>
    NOT?: Enumerable<shipWhereInput>
    id_ship?: IntFilter | number
    ds_ship?: StringFilter | string
    cd_company?: IntFilter | number
    Company?: XOR<CompanyRelationFilter, companyWhereInput>
    ship_client?: Ship_clientListRelationFilter
    ship_mariner?: Ship_marinerListRelationFilter
  }

  export type shipOrderByWithRelationInput = {
    id_ship?: SortOrder
    ds_ship?: SortOrder
    cd_company?: SortOrder
    Company?: companyOrderByWithRelationInput
    ship_client?: ship_clientOrderByRelationAggregateInput
    ship_mariner?: ship_marinerOrderByRelationAggregateInput
  }

  export type shipWhereUniqueInput = {
    id_ship?: number
  }

  export type shipOrderByWithAggregationInput = {
    id_ship?: SortOrder
    ds_ship?: SortOrder
    cd_company?: SortOrder
    _count?: shipCountOrderByAggregateInput
    _avg?: shipAvgOrderByAggregateInput
    _max?: shipMaxOrderByAggregateInput
    _min?: shipMinOrderByAggregateInput
    _sum?: shipSumOrderByAggregateInput
  }

  export type shipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<shipScalarWhereWithAggregatesInput>
    OR?: Enumerable<shipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<shipScalarWhereWithAggregatesInput>
    id_ship?: IntWithAggregatesFilter | number
    ds_ship?: StringWithAggregatesFilter | string
    cd_company?: IntWithAggregatesFilter | number
  }

  export type ship_marinerWhereInput = {
    AND?: Enumerable<ship_marinerWhereInput>
    OR?: Enumerable<ship_marinerWhereInput>
    NOT?: Enumerable<ship_marinerWhereInput>
    cd_ship?: IntFilter | number
    cd_mariner?: IntFilter | number
    id_cliente_mariner?: IntFilter | number
    Mariner?: XOR<MarinerRelationFilter, marinerWhereInput>
    Ship?: XOR<ShipRelationFilter, shipWhereInput>
  }

  export type ship_marinerOrderByWithRelationInput = {
    cd_ship?: SortOrder
    cd_mariner?: SortOrder
    id_cliente_mariner?: SortOrder
    Mariner?: marinerOrderByWithRelationInput
    Ship?: shipOrderByWithRelationInput
  }

  export type ship_marinerWhereUniqueInput = {
    id_cliente_mariner?: number
  }

  export type ship_marinerOrderByWithAggregationInput = {
    cd_ship?: SortOrder
    cd_mariner?: SortOrder
    id_cliente_mariner?: SortOrder
    _count?: ship_marinerCountOrderByAggregateInput
    _avg?: ship_marinerAvgOrderByAggregateInput
    _max?: ship_marinerMaxOrderByAggregateInput
    _min?: ship_marinerMinOrderByAggregateInput
    _sum?: ship_marinerSumOrderByAggregateInput
  }

  export type ship_marinerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ship_marinerScalarWhereWithAggregatesInput>
    OR?: Enumerable<ship_marinerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ship_marinerScalarWhereWithAggregatesInput>
    cd_ship?: IntWithAggregatesFilter | number
    cd_mariner?: IntWithAggregatesFilter | number
    id_cliente_mariner?: IntWithAggregatesFilter | number
  }

  export type ship_clientWhereInput = {
    AND?: Enumerable<ship_clientWhereInput>
    OR?: Enumerable<ship_clientWhereInput>
    NOT?: Enumerable<ship_clientWhereInput>
    cd_ship?: IntFilter | number
    cd_client?: IntFilter | number
    id_cliente_mariner?: IntFilter | number
    Client?: XOR<ClientRelationFilter, clientWhereInput>
    Ship?: XOR<ShipRelationFilter, shipWhereInput>
  }

  export type ship_clientOrderByWithRelationInput = {
    cd_ship?: SortOrder
    cd_client?: SortOrder
    id_cliente_mariner?: SortOrder
    Client?: clientOrderByWithRelationInput
    Ship?: shipOrderByWithRelationInput
  }

  export type ship_clientWhereUniqueInput = {
    id_cliente_mariner?: number
  }

  export type ship_clientOrderByWithAggregationInput = {
    cd_ship?: SortOrder
    cd_client?: SortOrder
    id_cliente_mariner?: SortOrder
    _count?: ship_clientCountOrderByAggregateInput
    _avg?: ship_clientAvgOrderByAggregateInput
    _max?: ship_clientMaxOrderByAggregateInput
    _min?: ship_clientMinOrderByAggregateInput
    _sum?: ship_clientSumOrderByAggregateInput
  }

  export type ship_clientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ship_clientScalarWhereWithAggregatesInput>
    OR?: Enumerable<ship_clientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ship_clientScalarWhereWithAggregatesInput>
    cd_ship?: IntWithAggregatesFilter | number
    cd_client?: IntWithAggregatesFilter | number
    id_cliente_mariner?: IntWithAggregatesFilter | number
  }

  export type movimentationWhereInput = {
    AND?: Enumerable<movimentationWhereInput>
    OR?: Enumerable<movimentationWhereInput>
    NOT?: Enumerable<movimentationWhereInput>
    id_movimentation?: IntFilter | number
    cd_company?: IntFilter | number
    dt_finished?: DateTimeNullableFilter | Date | string | null
    dt_opned?: DateTimeFilter | Date | string
    id_finished?: BoolFilter | boolean
    cd_move_status?: IntFilter | number
    cd_nav_plan?: IntNullableFilter | number | null
    Company?: XOR<CompanyRelationFilter, companyWhereInput>
    move_staus?: XOR<Move_statusRelationFilter, move_statusWhereInput>
    navagation_plan?: XOR<Navagation_planRelationFilter, navagation_planWhereInput> | null
  }

  export type movimentationOrderByWithRelationInput = {
    id_movimentation?: SortOrder
    cd_company?: SortOrder
    dt_finished?: SortOrder
    dt_opned?: SortOrder
    id_finished?: SortOrder
    cd_move_status?: SortOrder
    cd_nav_plan?: SortOrder
    Company?: companyOrderByWithRelationInput
    move_staus?: move_statusOrderByWithRelationInput
    navagation_plan?: navagation_planOrderByWithRelationInput
  }

  export type movimentationWhereUniqueInput = {
    id_movimentation?: number
  }

  export type movimentationOrderByWithAggregationInput = {
    id_movimentation?: SortOrder
    cd_company?: SortOrder
    dt_finished?: SortOrder
    dt_opned?: SortOrder
    id_finished?: SortOrder
    cd_move_status?: SortOrder
    cd_nav_plan?: SortOrder
    _count?: movimentationCountOrderByAggregateInput
    _avg?: movimentationAvgOrderByAggregateInput
    _max?: movimentationMaxOrderByAggregateInput
    _min?: movimentationMinOrderByAggregateInput
    _sum?: movimentationSumOrderByAggregateInput
  }

  export type movimentationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<movimentationScalarWhereWithAggregatesInput>
    OR?: Enumerable<movimentationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<movimentationScalarWhereWithAggregatesInput>
    id_movimentation?: IntWithAggregatesFilter | number
    cd_company?: IntWithAggregatesFilter | number
    dt_finished?: DateTimeNullableWithAggregatesFilter | Date | string | null
    dt_opned?: DateTimeWithAggregatesFilter | Date | string
    id_finished?: BoolWithAggregatesFilter | boolean
    cd_move_status?: IntWithAggregatesFilter | number
    cd_nav_plan?: IntNullableWithAggregatesFilter | number | null
  }

  export type navagation_planWhereInput = {
    AND?: Enumerable<navagation_planWhereInput>
    OR?: Enumerable<navagation_planWhereInput>
    NOT?: Enumerable<navagation_planWhereInput>
    qt_crew?: IntFilter | number
    qt_passengers?: IntFilter | number
    dt_departure?: DateTimeFilter | Date | string
    dt_arrival?: DateTimeNullableFilter | Date | string | null
    ds_observation?: StringNullableFilter | string | null
    cd_destiny?: IntFilter | number
    cd_user?: IntFilter | number
    cd_company?: IntFilter | number
    cd_move_status?: IntFilter | number
    id_nav_plan?: IntFilter | number
    Company?: XOR<CompanyRelationFilter, companyWhereInput>
    Location?: XOR<LocationRelationFilter, locationWhereInput>
    MoveStaus?: XOR<Move_statusRelationFilter, move_statusWhereInput>
    User?: XOR<UsersRelationFilter, usersWhereInput>
    movimentation?: MovimentationListRelationFilter
  }

  export type navagation_planOrderByWithRelationInput = {
    qt_crew?: SortOrder
    qt_passengers?: SortOrder
    dt_departure?: SortOrder
    dt_arrival?: SortOrder
    ds_observation?: SortOrder
    cd_destiny?: SortOrder
    cd_user?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    id_nav_plan?: SortOrder
    Company?: companyOrderByWithRelationInput
    Location?: locationOrderByWithRelationInput
    MoveStaus?: move_statusOrderByWithRelationInput
    User?: usersOrderByWithRelationInput
    movimentation?: movimentationOrderByRelationAggregateInput
  }

  export type navagation_planWhereUniqueInput = {
    id_nav_plan?: number
  }

  export type navagation_planOrderByWithAggregationInput = {
    qt_crew?: SortOrder
    qt_passengers?: SortOrder
    dt_departure?: SortOrder
    dt_arrival?: SortOrder
    ds_observation?: SortOrder
    cd_destiny?: SortOrder
    cd_user?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    id_nav_plan?: SortOrder
    _count?: navagation_planCountOrderByAggregateInput
    _avg?: navagation_planAvgOrderByAggregateInput
    _max?: navagation_planMaxOrderByAggregateInput
    _min?: navagation_planMinOrderByAggregateInput
    _sum?: navagation_planSumOrderByAggregateInput
  }

  export type navagation_planScalarWhereWithAggregatesInput = {
    AND?: Enumerable<navagation_planScalarWhereWithAggregatesInput>
    OR?: Enumerable<navagation_planScalarWhereWithAggregatesInput>
    NOT?: Enumerable<navagation_planScalarWhereWithAggregatesInput>
    qt_crew?: IntWithAggregatesFilter | number
    qt_passengers?: IntWithAggregatesFilter | number
    dt_departure?: DateTimeWithAggregatesFilter | Date | string
    dt_arrival?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ds_observation?: StringNullableWithAggregatesFilter | string | null
    cd_destiny?: IntWithAggregatesFilter | number
    cd_user?: IntWithAggregatesFilter | number
    cd_company?: IntWithAggregatesFilter | number
    cd_move_status?: IntWithAggregatesFilter | number
    id_nav_plan?: IntWithAggregatesFilter | number
  }

  export type usersCreateInput = {
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
    Company: companyCreateNestedOneWithoutUsersInput
    navagation_plan?: navagation_planCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id_user?: number
    cd_company: number
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
    Company?: companyUpdateOneRequiredWithoutUsersInput
    navagation_plan?: navagation_planUpdateManyWithoutUserInput
  }

  export type usersUncheckedUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutUserInput
  }

  export type usersCreateManyInput = {
    id_user?: number
    cd_company: number
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
  }

  export type usersUpdateManyMutationInput = {
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type companyCreateInput = {
    ds_cnpj: string
    ds_name: string
    client?: clientCreateNestedManyWithoutCompanyInput
    location?: locationCreateNestedManyWithoutCompanyInput
    mariner?: marinerCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planCreateNestedManyWithoutCompanyInput
    ship?: shipCreateNestedManyWithoutCompanyInput
    users?: usersCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    client?: clientUncheckedCreateNestedManyWithoutCompanyInput
    location?: locationUncheckedCreateNestedManyWithoutCompanyInput
    mariner?: marinerUncheckedCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationUncheckedCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutCompanyInput
    ship?: shipUncheckedCreateNestedManyWithoutCompanyInput
    users?: usersUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyUpdateInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateManyWithoutCompanyInput
    location?: locationUpdateManyWithoutCompanyInput
    mariner?: marinerUpdateManyWithoutCompanyInput
    movimentation?: movimentationUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUpdateManyWithoutCompanyInput
    ship?: shipUpdateManyWithoutCompanyInput
    users?: usersUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUncheckedUpdateManyWithoutCompanyInput
    location?: locationUncheckedUpdateManyWithoutCompanyInput
    mariner?: marinerUncheckedUpdateManyWithoutCompanyInput
    movimentation?: movimentationUncheckedUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutCompanyInput
    ship?: shipUncheckedUpdateManyWithoutCompanyInput
    users?: usersUncheckedUpdateManyWithoutCompanyInput
  }

  export type companyCreateManyInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
  }

  export type companyUpdateManyMutationInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
  }

  export type companyUncheckedUpdateManyInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
  }

  export type locationCreateInput = {
    ds_location: string
    Company: companyCreateNestedOneWithoutLocationInput
    navagation_plan?: navagation_planCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    id_location?: number
    ds_location: string
    cd_company: number
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationUpdateInput = {
    ds_location?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutLocationInput
    navagation_plan?: navagation_planUpdateManyWithoutLocationInput
  }

  export type locationUncheckedUpdateInput = {
    id_location?: IntFieldUpdateOperationsInput | number
    ds_location?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutLocationInput
  }

  export type locationCreateManyInput = {
    id_location?: number
    ds_location: string
    cd_company: number
  }

  export type locationUpdateManyMutationInput = {
    ds_location?: StringFieldUpdateOperationsInput | string
  }

  export type locationUncheckedUpdateManyInput = {
    id_location?: IntFieldUpdateOperationsInput | number
    ds_location?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
  }

  export type move_statusCreateInput = {
    ds_status: string
    movimentation?: movimentationCreateNestedManyWithoutMove_stausInput
    navagation_plan?: navagation_planCreateNestedManyWithoutMoveStausInput
  }

  export type move_statusUncheckedCreateInput = {
    id_status?: number
    ds_status: string
    movimentation?: movimentationUncheckedCreateNestedManyWithoutMove_stausInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutMoveStausInput
  }

  export type move_statusUpdateInput = {
    ds_status?: StringFieldUpdateOperationsInput | string
    movimentation?: movimentationUpdateManyWithoutMove_stausInput
    navagation_plan?: navagation_planUpdateManyWithoutMoveStausInput
  }

  export type move_statusUncheckedUpdateInput = {
    id_status?: IntFieldUpdateOperationsInput | number
    ds_status?: StringFieldUpdateOperationsInput | string
    movimentation?: movimentationUncheckedUpdateManyWithoutMove_stausInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutMoveStausInput
  }

  export type move_statusCreateManyInput = {
    id_status?: number
    ds_status: string
  }

  export type move_statusUpdateManyMutationInput = {
    ds_status?: StringFieldUpdateOperationsInput | string
  }

  export type move_statusUncheckedUpdateManyInput = {
    id_status?: IntFieldUpdateOperationsInput | number
    ds_status?: StringFieldUpdateOperationsInput | string
  }

  export type clientCreateInput = {
    ds_name: string
    ds_cpf: string
    Company: companyCreateNestedOneWithoutClientInput
    ship_client?: ship_clientCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateInput = {
    id_client?: number
    ds_name: string
    ds_cpf: string
    cd_company: number
    ship_client?: ship_clientUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientUpdateInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutClientInput
    ship_client?: ship_clientUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
    ship_client?: ship_clientUncheckedUpdateManyWithoutClientInput
  }

  export type clientCreateManyInput = {
    id_client?: number
    ds_name: string
    ds_cpf: string
    cd_company: number
  }

  export type clientUpdateManyMutationInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
  }

  export type clientUncheckedUpdateManyInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
  }

  export type marinerCreateInput = {
    ds_name: string
    ds_cpf: string
    Company: companyCreateNestedOneWithoutMarinerInput
    ship_mariner?: ship_marinerCreateNestedManyWithoutMarinerInput
  }

  export type marinerUncheckedCreateInput = {
    id_mariner?: number
    ds_name: string
    ds_cpf: string
    cd_company: number
    ship_mariner?: ship_marinerUncheckedCreateNestedManyWithoutMarinerInput
  }

  export type marinerUpdateInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutMarinerInput
    ship_mariner?: ship_marinerUpdateManyWithoutMarinerInput
  }

  export type marinerUncheckedUpdateInput = {
    id_mariner?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
    ship_mariner?: ship_marinerUncheckedUpdateManyWithoutMarinerInput
  }

  export type marinerCreateManyInput = {
    id_mariner?: number
    ds_name: string
    ds_cpf: string
    cd_company: number
  }

  export type marinerUpdateManyMutationInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
  }

  export type marinerUncheckedUpdateManyInput = {
    id_mariner?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
  }

  export type shipCreateInput = {
    ds_ship: string
    Company: companyCreateNestedOneWithoutShipInput
    ship_client?: ship_clientCreateNestedManyWithoutShipInput
    ship_mariner?: ship_marinerCreateNestedManyWithoutShipInput
  }

  export type shipUncheckedCreateInput = {
    id_ship?: number
    ds_ship: string
    cd_company: number
    ship_client?: ship_clientUncheckedCreateNestedManyWithoutShipInput
    ship_mariner?: ship_marinerUncheckedCreateNestedManyWithoutShipInput
  }

  export type shipUpdateInput = {
    ds_ship?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutShipInput
    ship_client?: ship_clientUpdateManyWithoutShipInput
    ship_mariner?: ship_marinerUpdateManyWithoutShipInput
  }

  export type shipUncheckedUpdateInput = {
    id_ship?: IntFieldUpdateOperationsInput | number
    ds_ship?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
    ship_client?: ship_clientUncheckedUpdateManyWithoutShipInput
    ship_mariner?: ship_marinerUncheckedUpdateManyWithoutShipInput
  }

  export type shipCreateManyInput = {
    id_ship?: number
    ds_ship: string
    cd_company: number
  }

  export type shipUpdateManyMutationInput = {
    ds_ship?: StringFieldUpdateOperationsInput | string
  }

  export type shipUncheckedUpdateManyInput = {
    id_ship?: IntFieldUpdateOperationsInput | number
    ds_ship?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
  }

  export type ship_marinerCreateInput = {
    Mariner: marinerCreateNestedOneWithoutShip_marinerInput
    Ship: shipCreateNestedOneWithoutShip_marinerInput
  }

  export type ship_marinerUncheckedCreateInput = {
    cd_ship: number
    cd_mariner: number
    id_cliente_mariner?: number
  }

  export type ship_marinerUpdateInput = {
    Mariner?: marinerUpdateOneRequiredWithoutShip_marinerInput
    Ship?: shipUpdateOneRequiredWithoutShip_marinerInput
  }

  export type ship_marinerUncheckedUpdateInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    cd_mariner?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_marinerCreateManyInput = {
    cd_ship: number
    cd_mariner: number
    id_cliente_mariner?: number
  }

  export type ship_marinerUpdateManyMutationInput = {

  }

  export type ship_marinerUncheckedUpdateManyInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    cd_mariner?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_clientCreateInput = {
    Client: clientCreateNestedOneWithoutShip_clientInput
    Ship: shipCreateNestedOneWithoutShip_clientInput
  }

  export type ship_clientUncheckedCreateInput = {
    cd_ship: number
    cd_client: number
    id_cliente_mariner?: number
  }

  export type ship_clientUpdateInput = {
    Client?: clientUpdateOneRequiredWithoutShip_clientInput
    Ship?: shipUpdateOneRequiredWithoutShip_clientInput
  }

  export type ship_clientUncheckedUpdateInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    cd_client?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_clientCreateManyInput = {
    cd_ship: number
    cd_client: number
    id_cliente_mariner?: number
  }

  export type ship_clientUpdateManyMutationInput = {

  }

  export type ship_clientUncheckedUpdateManyInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    cd_client?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type movimentationCreateInput = {
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    Company: companyCreateNestedOneWithoutMovimentationInput
    move_staus: move_statusCreateNestedOneWithoutMovimentationInput
    navagation_plan?: navagation_planCreateNestedOneWithoutMovimentationInput
  }

  export type movimentationUncheckedCreateInput = {
    id_movimentation?: number
    cd_company: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_move_status: number
    cd_nav_plan?: number | null
  }

  export type movimentationUpdateInput = {
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    Company?: companyUpdateOneRequiredWithoutMovimentationInput
    move_staus?: move_statusUpdateOneRequiredWithoutMovimentationInput
    navagation_plan?: navagation_planUpdateOneWithoutMovimentationInput
  }

  export type movimentationUncheckedUpdateInput = {
    id_movimentation?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    cd_move_status?: IntFieldUpdateOperationsInput | number
    cd_nav_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type movimentationCreateManyInput = {
    id_movimentation?: number
    cd_company: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_move_status: number
    cd_nav_plan?: number | null
  }

  export type movimentationUpdateManyMutationInput = {
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type movimentationUncheckedUpdateManyInput = {
    id_movimentation?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    cd_move_status?: IntFieldUpdateOperationsInput | number
    cd_nav_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type navagation_planCreateInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    Company: companyCreateNestedOneWithoutNavagation_planInput
    Location: locationCreateNestedOneWithoutNavagation_planInput
    MoveStaus: move_statusCreateNestedOneWithoutNavagation_planInput
    User: usersCreateNestedOneWithoutNavagation_planInput
    movimentation?: movimentationCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedCreateInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_user: number
    cd_company: number
    cd_move_status: number
    id_nav_plan?: number
    movimentation?: movimentationUncheckedCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planUpdateInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    Company?: companyUpdateOneRequiredWithoutNavagation_planInput
    Location?: locationUpdateOneRequiredWithoutNavagation_planInput
    MoveStaus?: move_statusUpdateOneRequiredWithoutNavagation_planInput
    User?: usersUpdateOneRequiredWithoutNavagation_planInput
    movimentation?: movimentationUpdateManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedUpdateInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_destiny?: IntFieldUpdateOperationsInput | number
    cd_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    cd_move_status?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
    movimentation?: movimentationUncheckedUpdateManyWithoutNavagation_planInput
  }

  export type navagation_planCreateManyInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_user: number
    cd_company: number
    cd_move_status: number
    id_nav_plan?: number
  }

  export type navagation_planUpdateManyMutationInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type navagation_planUncheckedUpdateManyInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_destiny?: IntFieldUpdateOperationsInput | number
    cd_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    cd_move_status?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type CompanyRelationFilter = {
    is?: companyWhereInput
    isNot?: companyWhereInput
  }

  export type Navagation_planListRelationFilter = {
    every?: navagation_planWhereInput
    some?: navagation_planWhereInput
    none?: navagation_planWhereInput
  }

  export type navagation_planOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id_user?: SortOrder
    cd_company?: SortOrder
    ds_email?: SortOrder
    ds_name?: SortOrder
    ds_password?: SortOrder
    id_manager?: SortOrder
    id_operational?: SortOrder
    id_operator?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id_user?: SortOrder
    cd_company?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id_user?: SortOrder
    cd_company?: SortOrder
    ds_email?: SortOrder
    ds_name?: SortOrder
    ds_password?: SortOrder
    id_manager?: SortOrder
    id_operational?: SortOrder
    id_operator?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id_user?: SortOrder
    cd_company?: SortOrder
    ds_email?: SortOrder
    ds_name?: SortOrder
    ds_password?: SortOrder
    id_manager?: SortOrder
    id_operational?: SortOrder
    id_operator?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id_user?: SortOrder
    cd_company?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type ClientListRelationFilter = {
    every?: clientWhereInput
    some?: clientWhereInput
    none?: clientWhereInput
  }

  export type LocationListRelationFilter = {
    every?: locationWhereInput
    some?: locationWhereInput
    none?: locationWhereInput
  }

  export type MarinerListRelationFilter = {
    every?: marinerWhereInput
    some?: marinerWhereInput
    none?: marinerWhereInput
  }

  export type MovimentationListRelationFilter = {
    every?: movimentationWhereInput
    some?: movimentationWhereInput
    none?: movimentationWhereInput
  }

  export type ShipListRelationFilter = {
    every?: shipWhereInput
    some?: shipWhereInput
    none?: shipWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type clientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marinerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type movimentationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type shipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyCountOrderByAggregateInput = {
    id_company?: SortOrder
    ds_cnpj?: SortOrder
    ds_name?: SortOrder
  }

  export type companyAvgOrderByAggregateInput = {
    id_company?: SortOrder
  }

  export type companyMaxOrderByAggregateInput = {
    id_company?: SortOrder
    ds_cnpj?: SortOrder
    ds_name?: SortOrder
  }

  export type companyMinOrderByAggregateInput = {
    id_company?: SortOrder
    ds_cnpj?: SortOrder
    ds_name?: SortOrder
  }

  export type companySumOrderByAggregateInput = {
    id_company?: SortOrder
  }

  export type locationCountOrderByAggregateInput = {
    id_location?: SortOrder
    ds_location?: SortOrder
    cd_company?: SortOrder
  }

  export type locationAvgOrderByAggregateInput = {
    id_location?: SortOrder
    cd_company?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    id_location?: SortOrder
    ds_location?: SortOrder
    cd_company?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    id_location?: SortOrder
    ds_location?: SortOrder
    cd_company?: SortOrder
  }

  export type locationSumOrderByAggregateInput = {
    id_location?: SortOrder
    cd_company?: SortOrder
  }

  export type move_statusCountOrderByAggregateInput = {
    id_status?: SortOrder
    ds_status?: SortOrder
  }

  export type move_statusAvgOrderByAggregateInput = {
    id_status?: SortOrder
  }

  export type move_statusMaxOrderByAggregateInput = {
    id_status?: SortOrder
    ds_status?: SortOrder
  }

  export type move_statusMinOrderByAggregateInput = {
    id_status?: SortOrder
    ds_status?: SortOrder
  }

  export type move_statusSumOrderByAggregateInput = {
    id_status?: SortOrder
  }

  export type Ship_clientListRelationFilter = {
    every?: ship_clientWhereInput
    some?: ship_clientWhereInput
    none?: ship_clientWhereInput
  }

  export type ship_clientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientCountOrderByAggregateInput = {
    id_client?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
  }

  export type clientAvgOrderByAggregateInput = {
    id_client?: SortOrder
    cd_company?: SortOrder
  }

  export type clientMaxOrderByAggregateInput = {
    id_client?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
  }

  export type clientMinOrderByAggregateInput = {
    id_client?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
  }

  export type clientSumOrderByAggregateInput = {
    id_client?: SortOrder
    cd_company?: SortOrder
  }

  export type Ship_marinerListRelationFilter = {
    every?: ship_marinerWhereInput
    some?: ship_marinerWhereInput
    none?: ship_marinerWhereInput
  }

  export type ship_marinerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marinerCountOrderByAggregateInput = {
    id_mariner?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
  }

  export type marinerAvgOrderByAggregateInput = {
    id_mariner?: SortOrder
    cd_company?: SortOrder
  }

  export type marinerMaxOrderByAggregateInput = {
    id_mariner?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
  }

  export type marinerMinOrderByAggregateInput = {
    id_mariner?: SortOrder
    ds_name?: SortOrder
    ds_cpf?: SortOrder
    cd_company?: SortOrder
  }

  export type marinerSumOrderByAggregateInput = {
    id_mariner?: SortOrder
    cd_company?: SortOrder
  }

  export type shipCountOrderByAggregateInput = {
    id_ship?: SortOrder
    ds_ship?: SortOrder
    cd_company?: SortOrder
  }

  export type shipAvgOrderByAggregateInput = {
    id_ship?: SortOrder
    cd_company?: SortOrder
  }

  export type shipMaxOrderByAggregateInput = {
    id_ship?: SortOrder
    ds_ship?: SortOrder
    cd_company?: SortOrder
  }

  export type shipMinOrderByAggregateInput = {
    id_ship?: SortOrder
    ds_ship?: SortOrder
    cd_company?: SortOrder
  }

  export type shipSumOrderByAggregateInput = {
    id_ship?: SortOrder
    cd_company?: SortOrder
  }

  export type MarinerRelationFilter = {
    is?: marinerWhereInput
    isNot?: marinerWhereInput
  }

  export type ShipRelationFilter = {
    is?: shipWhereInput
    isNot?: shipWhereInput
  }

  export type ship_marinerCountOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_mariner?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_marinerAvgOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_mariner?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_marinerMaxOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_mariner?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_marinerMinOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_mariner?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_marinerSumOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_mariner?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ClientRelationFilter = {
    is?: clientWhereInput
    isNot?: clientWhereInput
  }

  export type ship_clientCountOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_client?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_clientAvgOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_client?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_clientMaxOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_client?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_clientMinOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_client?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type ship_clientSumOrderByAggregateInput = {
    cd_ship?: SortOrder
    cd_client?: SortOrder
    id_cliente_mariner?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type Move_statusRelationFilter = {
    is?: move_statusWhereInput
    isNot?: move_statusWhereInput
  }

  export type Navagation_planRelationFilter = {
    is?: navagation_planWhereInput | null
    isNot?: navagation_planWhereInput | null
  }

  export type movimentationCountOrderByAggregateInput = {
    id_movimentation?: SortOrder
    cd_company?: SortOrder
    dt_finished?: SortOrder
    dt_opned?: SortOrder
    id_finished?: SortOrder
    cd_move_status?: SortOrder
    cd_nav_plan?: SortOrder
  }

  export type movimentationAvgOrderByAggregateInput = {
    id_movimentation?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    cd_nav_plan?: SortOrder
  }

  export type movimentationMaxOrderByAggregateInput = {
    id_movimentation?: SortOrder
    cd_company?: SortOrder
    dt_finished?: SortOrder
    dt_opned?: SortOrder
    id_finished?: SortOrder
    cd_move_status?: SortOrder
    cd_nav_plan?: SortOrder
  }

  export type movimentationMinOrderByAggregateInput = {
    id_movimentation?: SortOrder
    cd_company?: SortOrder
    dt_finished?: SortOrder
    dt_opned?: SortOrder
    id_finished?: SortOrder
    cd_move_status?: SortOrder
    cd_nav_plan?: SortOrder
  }

  export type movimentationSumOrderByAggregateInput = {
    id_movimentation?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    cd_nav_plan?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type LocationRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type navagation_planCountOrderByAggregateInput = {
    qt_crew?: SortOrder
    qt_passengers?: SortOrder
    dt_departure?: SortOrder
    dt_arrival?: SortOrder
    ds_observation?: SortOrder
    cd_destiny?: SortOrder
    cd_user?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    id_nav_plan?: SortOrder
  }

  export type navagation_planAvgOrderByAggregateInput = {
    qt_crew?: SortOrder
    qt_passengers?: SortOrder
    cd_destiny?: SortOrder
    cd_user?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    id_nav_plan?: SortOrder
  }

  export type navagation_planMaxOrderByAggregateInput = {
    qt_crew?: SortOrder
    qt_passengers?: SortOrder
    dt_departure?: SortOrder
    dt_arrival?: SortOrder
    ds_observation?: SortOrder
    cd_destiny?: SortOrder
    cd_user?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    id_nav_plan?: SortOrder
  }

  export type navagation_planMinOrderByAggregateInput = {
    qt_crew?: SortOrder
    qt_passengers?: SortOrder
    dt_departure?: SortOrder
    dt_arrival?: SortOrder
    ds_observation?: SortOrder
    cd_destiny?: SortOrder
    cd_user?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    id_nav_plan?: SortOrder
  }

  export type navagation_planSumOrderByAggregateInput = {
    qt_crew?: SortOrder
    qt_passengers?: SortOrder
    cd_destiny?: SortOrder
    cd_user?: SortOrder
    cd_company?: SortOrder
    cd_move_status?: SortOrder
    id_nav_plan?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type companyCreateNestedOneWithoutUsersInput = {
    create?: XOR<companyCreateWithoutUsersInput, companyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companyCreateOrConnectWithoutUsersInput
    connect?: companyWhereUniqueInput
  }

  export type navagation_planCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutUserInput>, Enumerable<navagation_planUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutUserInput>
    createMany?: navagation_planCreateManyUserInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type navagation_planUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutUserInput>, Enumerable<navagation_planUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutUserInput>
    createMany?: navagation_planCreateManyUserInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type companyUpdateOneRequiredWithoutUsersInput = {
    create?: XOR<companyCreateWithoutUsersInput, companyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companyCreateOrConnectWithoutUsersInput
    upsert?: companyUpsertWithoutUsersInput
    connect?: companyWhereUniqueInput
    update?: XOR<companyUpdateWithoutUsersInput, companyUncheckedUpdateWithoutUsersInput>
  }

  export type navagation_planUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutUserInput>, Enumerable<navagation_planUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutUserInput>
    createMany?: navagation_planCreateManyUserInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type navagation_planUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutUserInput>, Enumerable<navagation_planUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutUserInput>
    createMany?: navagation_planCreateManyUserInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type clientCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<clientCreateWithoutCompanyInput>, Enumerable<clientUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutCompanyInput>
    createMany?: clientCreateManyCompanyInputEnvelope
    connect?: Enumerable<clientWhereUniqueInput>
  }

  export type locationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<locationCreateWithoutCompanyInput>, Enumerable<locationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCompanyInput>
    createMany?: locationCreateManyCompanyInputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type marinerCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<marinerCreateWithoutCompanyInput>, Enumerable<marinerUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<marinerCreateOrConnectWithoutCompanyInput>
    createMany?: marinerCreateManyCompanyInputEnvelope
    connect?: Enumerable<marinerWhereUniqueInput>
  }

  export type movimentationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutCompanyInput>, Enumerable<movimentationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutCompanyInput>
    createMany?: movimentationCreateManyCompanyInputEnvelope
    connect?: Enumerable<movimentationWhereUniqueInput>
  }

  export type navagation_planCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutCompanyInput>, Enumerable<navagation_planUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutCompanyInput>
    createMany?: navagation_planCreateManyCompanyInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type shipCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<shipCreateWithoutCompanyInput>, Enumerable<shipUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<shipCreateOrConnectWithoutCompanyInput>
    createMany?: shipCreateManyCompanyInputEnvelope
    connect?: Enumerable<shipWhereUniqueInput>
  }

  export type usersCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<usersCreateWithoutCompanyInput>, Enumerable<usersUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutCompanyInput>
    createMany?: usersCreateManyCompanyInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type clientUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<clientCreateWithoutCompanyInput>, Enumerable<clientUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutCompanyInput>
    createMany?: clientCreateManyCompanyInputEnvelope
    connect?: Enumerable<clientWhereUniqueInput>
  }

  export type locationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<locationCreateWithoutCompanyInput>, Enumerable<locationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCompanyInput>
    createMany?: locationCreateManyCompanyInputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type marinerUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<marinerCreateWithoutCompanyInput>, Enumerable<marinerUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<marinerCreateOrConnectWithoutCompanyInput>
    createMany?: marinerCreateManyCompanyInputEnvelope
    connect?: Enumerable<marinerWhereUniqueInput>
  }

  export type movimentationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutCompanyInput>, Enumerable<movimentationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutCompanyInput>
    createMany?: movimentationCreateManyCompanyInputEnvelope
    connect?: Enumerable<movimentationWhereUniqueInput>
  }

  export type navagation_planUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutCompanyInput>, Enumerable<navagation_planUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutCompanyInput>
    createMany?: navagation_planCreateManyCompanyInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type shipUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<shipCreateWithoutCompanyInput>, Enumerable<shipUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<shipCreateOrConnectWithoutCompanyInput>
    createMany?: shipCreateManyCompanyInputEnvelope
    connect?: Enumerable<shipWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<usersCreateWithoutCompanyInput>, Enumerable<usersUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutCompanyInput>
    createMany?: usersCreateManyCompanyInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type clientUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<clientCreateWithoutCompanyInput>, Enumerable<clientUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<clientUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: clientCreateManyCompanyInputEnvelope
    set?: Enumerable<clientWhereUniqueInput>
    disconnect?: Enumerable<clientWhereUniqueInput>
    delete?: Enumerable<clientWhereUniqueInput>
    connect?: Enumerable<clientWhereUniqueInput>
    update?: Enumerable<clientUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<clientUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<clientScalarWhereInput>
  }

  export type locationUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<locationCreateWithoutCompanyInput>, Enumerable<locationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: locationCreateManyCompanyInputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type marinerUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<marinerCreateWithoutCompanyInput>, Enumerable<marinerUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<marinerCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<marinerUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: marinerCreateManyCompanyInputEnvelope
    set?: Enumerable<marinerWhereUniqueInput>
    disconnect?: Enumerable<marinerWhereUniqueInput>
    delete?: Enumerable<marinerWhereUniqueInput>
    connect?: Enumerable<marinerWhereUniqueInput>
    update?: Enumerable<marinerUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<marinerUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<marinerScalarWhereInput>
  }

  export type movimentationUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutCompanyInput>, Enumerable<movimentationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<movimentationUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: movimentationCreateManyCompanyInputEnvelope
    set?: Enumerable<movimentationWhereUniqueInput>
    disconnect?: Enumerable<movimentationWhereUniqueInput>
    delete?: Enumerable<movimentationWhereUniqueInput>
    connect?: Enumerable<movimentationWhereUniqueInput>
    update?: Enumerable<movimentationUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<movimentationUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<movimentationScalarWhereInput>
  }

  export type navagation_planUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutCompanyInput>, Enumerable<navagation_planUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: navagation_planCreateManyCompanyInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type shipUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<shipCreateWithoutCompanyInput>, Enumerable<shipUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<shipCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<shipUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: shipCreateManyCompanyInputEnvelope
    set?: Enumerable<shipWhereUniqueInput>
    disconnect?: Enumerable<shipWhereUniqueInput>
    delete?: Enumerable<shipWhereUniqueInput>
    connect?: Enumerable<shipWhereUniqueInput>
    update?: Enumerable<shipUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<shipUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<shipScalarWhereInput>
  }

  export type usersUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<usersCreateWithoutCompanyInput>, Enumerable<usersUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: usersCreateManyCompanyInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type clientUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<clientCreateWithoutCompanyInput>, Enumerable<clientUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<clientUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: clientCreateManyCompanyInputEnvelope
    set?: Enumerable<clientWhereUniqueInput>
    disconnect?: Enumerable<clientWhereUniqueInput>
    delete?: Enumerable<clientWhereUniqueInput>
    connect?: Enumerable<clientWhereUniqueInput>
    update?: Enumerable<clientUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<clientUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<clientScalarWhereInput>
  }

  export type locationUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<locationCreateWithoutCompanyInput>, Enumerable<locationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: locationCreateManyCompanyInputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type marinerUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<marinerCreateWithoutCompanyInput>, Enumerable<marinerUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<marinerCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<marinerUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: marinerCreateManyCompanyInputEnvelope
    set?: Enumerable<marinerWhereUniqueInput>
    disconnect?: Enumerable<marinerWhereUniqueInput>
    delete?: Enumerable<marinerWhereUniqueInput>
    connect?: Enumerable<marinerWhereUniqueInput>
    update?: Enumerable<marinerUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<marinerUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<marinerScalarWhereInput>
  }

  export type movimentationUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutCompanyInput>, Enumerable<movimentationUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<movimentationUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: movimentationCreateManyCompanyInputEnvelope
    set?: Enumerable<movimentationWhereUniqueInput>
    disconnect?: Enumerable<movimentationWhereUniqueInput>
    delete?: Enumerable<movimentationWhereUniqueInput>
    connect?: Enumerable<movimentationWhereUniqueInput>
    update?: Enumerable<movimentationUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<movimentationUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<movimentationScalarWhereInput>
  }

  export type navagation_planUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutCompanyInput>, Enumerable<navagation_planUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: navagation_planCreateManyCompanyInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type shipUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<shipCreateWithoutCompanyInput>, Enumerable<shipUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<shipCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<shipUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: shipCreateManyCompanyInputEnvelope
    set?: Enumerable<shipWhereUniqueInput>
    disconnect?: Enumerable<shipWhereUniqueInput>
    delete?: Enumerable<shipWhereUniqueInput>
    connect?: Enumerable<shipWhereUniqueInput>
    update?: Enumerable<shipUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<shipUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<shipScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<usersCreateWithoutCompanyInput>, Enumerable<usersUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: usersCreateManyCompanyInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type companyCreateNestedOneWithoutLocationInput = {
    create?: XOR<companyCreateWithoutLocationInput, companyUncheckedCreateWithoutLocationInput>
    connectOrCreate?: companyCreateOrConnectWithoutLocationInput
    connect?: companyWhereUniqueInput
  }

  export type navagation_planCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutLocationInput>, Enumerable<navagation_planUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutLocationInput>
    createMany?: navagation_planCreateManyLocationInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type navagation_planUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutLocationInput>, Enumerable<navagation_planUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutLocationInput>
    createMany?: navagation_planCreateManyLocationInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type companyUpdateOneRequiredWithoutLocationInput = {
    create?: XOR<companyCreateWithoutLocationInput, companyUncheckedCreateWithoutLocationInput>
    connectOrCreate?: companyCreateOrConnectWithoutLocationInput
    upsert?: companyUpsertWithoutLocationInput
    connect?: companyWhereUniqueInput
    update?: XOR<companyUpdateWithoutLocationInput, companyUncheckedUpdateWithoutLocationInput>
  }

  export type navagation_planUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutLocationInput>, Enumerable<navagation_planUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: navagation_planCreateManyLocationInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type navagation_planUncheckedUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutLocationInput>, Enumerable<navagation_planUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: navagation_planCreateManyLocationInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type movimentationCreateNestedManyWithoutMove_stausInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutMove_stausInput>, Enumerable<movimentationUncheckedCreateWithoutMove_stausInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutMove_stausInput>
    createMany?: movimentationCreateManyMove_stausInputEnvelope
    connect?: Enumerable<movimentationWhereUniqueInput>
  }

  export type navagation_planCreateNestedManyWithoutMoveStausInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutMoveStausInput>, Enumerable<navagation_planUncheckedCreateWithoutMoveStausInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutMoveStausInput>
    createMany?: navagation_planCreateManyMoveStausInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type movimentationUncheckedCreateNestedManyWithoutMove_stausInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutMove_stausInput>, Enumerable<movimentationUncheckedCreateWithoutMove_stausInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutMove_stausInput>
    createMany?: movimentationCreateManyMove_stausInputEnvelope
    connect?: Enumerable<movimentationWhereUniqueInput>
  }

  export type navagation_planUncheckedCreateNestedManyWithoutMoveStausInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutMoveStausInput>, Enumerable<navagation_planUncheckedCreateWithoutMoveStausInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutMoveStausInput>
    createMany?: navagation_planCreateManyMoveStausInputEnvelope
    connect?: Enumerable<navagation_planWhereUniqueInput>
  }

  export type movimentationUpdateManyWithoutMove_stausInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutMove_stausInput>, Enumerable<movimentationUncheckedCreateWithoutMove_stausInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutMove_stausInput>
    upsert?: Enumerable<movimentationUpsertWithWhereUniqueWithoutMove_stausInput>
    createMany?: movimentationCreateManyMove_stausInputEnvelope
    set?: Enumerable<movimentationWhereUniqueInput>
    disconnect?: Enumerable<movimentationWhereUniqueInput>
    delete?: Enumerable<movimentationWhereUniqueInput>
    connect?: Enumerable<movimentationWhereUniqueInput>
    update?: Enumerable<movimentationUpdateWithWhereUniqueWithoutMove_stausInput>
    updateMany?: Enumerable<movimentationUpdateManyWithWhereWithoutMove_stausInput>
    deleteMany?: Enumerable<movimentationScalarWhereInput>
  }

  export type navagation_planUpdateManyWithoutMoveStausInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutMoveStausInput>, Enumerable<navagation_planUncheckedCreateWithoutMoveStausInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutMoveStausInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutMoveStausInput>
    createMany?: navagation_planCreateManyMoveStausInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutMoveStausInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutMoveStausInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type movimentationUncheckedUpdateManyWithoutMove_stausInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutMove_stausInput>, Enumerable<movimentationUncheckedCreateWithoutMove_stausInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutMove_stausInput>
    upsert?: Enumerable<movimentationUpsertWithWhereUniqueWithoutMove_stausInput>
    createMany?: movimentationCreateManyMove_stausInputEnvelope
    set?: Enumerable<movimentationWhereUniqueInput>
    disconnect?: Enumerable<movimentationWhereUniqueInput>
    delete?: Enumerable<movimentationWhereUniqueInput>
    connect?: Enumerable<movimentationWhereUniqueInput>
    update?: Enumerable<movimentationUpdateWithWhereUniqueWithoutMove_stausInput>
    updateMany?: Enumerable<movimentationUpdateManyWithWhereWithoutMove_stausInput>
    deleteMany?: Enumerable<movimentationScalarWhereInput>
  }

  export type navagation_planUncheckedUpdateManyWithoutMoveStausInput = {
    create?: XOR<Enumerable<navagation_planCreateWithoutMoveStausInput>, Enumerable<navagation_planUncheckedCreateWithoutMoveStausInput>>
    connectOrCreate?: Enumerable<navagation_planCreateOrConnectWithoutMoveStausInput>
    upsert?: Enumerable<navagation_planUpsertWithWhereUniqueWithoutMoveStausInput>
    createMany?: navagation_planCreateManyMoveStausInputEnvelope
    set?: Enumerable<navagation_planWhereUniqueInput>
    disconnect?: Enumerable<navagation_planWhereUniqueInput>
    delete?: Enumerable<navagation_planWhereUniqueInput>
    connect?: Enumerable<navagation_planWhereUniqueInput>
    update?: Enumerable<navagation_planUpdateWithWhereUniqueWithoutMoveStausInput>
    updateMany?: Enumerable<navagation_planUpdateManyWithWhereWithoutMoveStausInput>
    deleteMany?: Enumerable<navagation_planScalarWhereInput>
  }

  export type companyCreateNestedOneWithoutClientInput = {
    create?: XOR<companyCreateWithoutClientInput, companyUncheckedCreateWithoutClientInput>
    connectOrCreate?: companyCreateOrConnectWithoutClientInput
    connect?: companyWhereUniqueInput
  }

  export type ship_clientCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutClientInput>, Enumerable<ship_clientUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutClientInput>
    createMany?: ship_clientCreateManyClientInputEnvelope
    connect?: Enumerable<ship_clientWhereUniqueInput>
  }

  export type ship_clientUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutClientInput>, Enumerable<ship_clientUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutClientInput>
    createMany?: ship_clientCreateManyClientInputEnvelope
    connect?: Enumerable<ship_clientWhereUniqueInput>
  }

  export type companyUpdateOneRequiredWithoutClientInput = {
    create?: XOR<companyCreateWithoutClientInput, companyUncheckedCreateWithoutClientInput>
    connectOrCreate?: companyCreateOrConnectWithoutClientInput
    upsert?: companyUpsertWithoutClientInput
    connect?: companyWhereUniqueInput
    update?: XOR<companyUpdateWithoutClientInput, companyUncheckedUpdateWithoutClientInput>
  }

  export type ship_clientUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutClientInput>, Enumerable<ship_clientUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ship_clientUpsertWithWhereUniqueWithoutClientInput>
    createMany?: ship_clientCreateManyClientInputEnvelope
    set?: Enumerable<ship_clientWhereUniqueInput>
    disconnect?: Enumerable<ship_clientWhereUniqueInput>
    delete?: Enumerable<ship_clientWhereUniqueInput>
    connect?: Enumerable<ship_clientWhereUniqueInput>
    update?: Enumerable<ship_clientUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ship_clientUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ship_clientScalarWhereInput>
  }

  export type ship_clientUncheckedUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutClientInput>, Enumerable<ship_clientUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ship_clientUpsertWithWhereUniqueWithoutClientInput>
    createMany?: ship_clientCreateManyClientInputEnvelope
    set?: Enumerable<ship_clientWhereUniqueInput>
    disconnect?: Enumerable<ship_clientWhereUniqueInput>
    delete?: Enumerable<ship_clientWhereUniqueInput>
    connect?: Enumerable<ship_clientWhereUniqueInput>
    update?: Enumerable<ship_clientUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ship_clientUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ship_clientScalarWhereInput>
  }

  export type companyCreateNestedOneWithoutMarinerInput = {
    create?: XOR<companyCreateWithoutMarinerInput, companyUncheckedCreateWithoutMarinerInput>
    connectOrCreate?: companyCreateOrConnectWithoutMarinerInput
    connect?: companyWhereUniqueInput
  }

  export type ship_marinerCreateNestedManyWithoutMarinerInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutMarinerInput>, Enumerable<ship_marinerUncheckedCreateWithoutMarinerInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutMarinerInput>
    createMany?: ship_marinerCreateManyMarinerInputEnvelope
    connect?: Enumerable<ship_marinerWhereUniqueInput>
  }

  export type ship_marinerUncheckedCreateNestedManyWithoutMarinerInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutMarinerInput>, Enumerable<ship_marinerUncheckedCreateWithoutMarinerInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutMarinerInput>
    createMany?: ship_marinerCreateManyMarinerInputEnvelope
    connect?: Enumerable<ship_marinerWhereUniqueInput>
  }

  export type companyUpdateOneRequiredWithoutMarinerInput = {
    create?: XOR<companyCreateWithoutMarinerInput, companyUncheckedCreateWithoutMarinerInput>
    connectOrCreate?: companyCreateOrConnectWithoutMarinerInput
    upsert?: companyUpsertWithoutMarinerInput
    connect?: companyWhereUniqueInput
    update?: XOR<companyUpdateWithoutMarinerInput, companyUncheckedUpdateWithoutMarinerInput>
  }

  export type ship_marinerUpdateManyWithoutMarinerInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutMarinerInput>, Enumerable<ship_marinerUncheckedCreateWithoutMarinerInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutMarinerInput>
    upsert?: Enumerable<ship_marinerUpsertWithWhereUniqueWithoutMarinerInput>
    createMany?: ship_marinerCreateManyMarinerInputEnvelope
    set?: Enumerable<ship_marinerWhereUniqueInput>
    disconnect?: Enumerable<ship_marinerWhereUniqueInput>
    delete?: Enumerable<ship_marinerWhereUniqueInput>
    connect?: Enumerable<ship_marinerWhereUniqueInput>
    update?: Enumerable<ship_marinerUpdateWithWhereUniqueWithoutMarinerInput>
    updateMany?: Enumerable<ship_marinerUpdateManyWithWhereWithoutMarinerInput>
    deleteMany?: Enumerable<ship_marinerScalarWhereInput>
  }

  export type ship_marinerUncheckedUpdateManyWithoutMarinerInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutMarinerInput>, Enumerable<ship_marinerUncheckedCreateWithoutMarinerInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutMarinerInput>
    upsert?: Enumerable<ship_marinerUpsertWithWhereUniqueWithoutMarinerInput>
    createMany?: ship_marinerCreateManyMarinerInputEnvelope
    set?: Enumerable<ship_marinerWhereUniqueInput>
    disconnect?: Enumerable<ship_marinerWhereUniqueInput>
    delete?: Enumerable<ship_marinerWhereUniqueInput>
    connect?: Enumerable<ship_marinerWhereUniqueInput>
    update?: Enumerable<ship_marinerUpdateWithWhereUniqueWithoutMarinerInput>
    updateMany?: Enumerable<ship_marinerUpdateManyWithWhereWithoutMarinerInput>
    deleteMany?: Enumerable<ship_marinerScalarWhereInput>
  }

  export type companyCreateNestedOneWithoutShipInput = {
    create?: XOR<companyCreateWithoutShipInput, companyUncheckedCreateWithoutShipInput>
    connectOrCreate?: companyCreateOrConnectWithoutShipInput
    connect?: companyWhereUniqueInput
  }

  export type ship_clientCreateNestedManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutShipInput>, Enumerable<ship_clientUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutShipInput>
    createMany?: ship_clientCreateManyShipInputEnvelope
    connect?: Enumerable<ship_clientWhereUniqueInput>
  }

  export type ship_marinerCreateNestedManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutShipInput>, Enumerable<ship_marinerUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutShipInput>
    createMany?: ship_marinerCreateManyShipInputEnvelope
    connect?: Enumerable<ship_marinerWhereUniqueInput>
  }

  export type ship_clientUncheckedCreateNestedManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutShipInput>, Enumerable<ship_clientUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutShipInput>
    createMany?: ship_clientCreateManyShipInputEnvelope
    connect?: Enumerable<ship_clientWhereUniqueInput>
  }

  export type ship_marinerUncheckedCreateNestedManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutShipInput>, Enumerable<ship_marinerUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutShipInput>
    createMany?: ship_marinerCreateManyShipInputEnvelope
    connect?: Enumerable<ship_marinerWhereUniqueInput>
  }

  export type companyUpdateOneRequiredWithoutShipInput = {
    create?: XOR<companyCreateWithoutShipInput, companyUncheckedCreateWithoutShipInput>
    connectOrCreate?: companyCreateOrConnectWithoutShipInput
    upsert?: companyUpsertWithoutShipInput
    connect?: companyWhereUniqueInput
    update?: XOR<companyUpdateWithoutShipInput, companyUncheckedUpdateWithoutShipInput>
  }

  export type ship_clientUpdateManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutShipInput>, Enumerable<ship_clientUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutShipInput>
    upsert?: Enumerable<ship_clientUpsertWithWhereUniqueWithoutShipInput>
    createMany?: ship_clientCreateManyShipInputEnvelope
    set?: Enumerable<ship_clientWhereUniqueInput>
    disconnect?: Enumerable<ship_clientWhereUniqueInput>
    delete?: Enumerable<ship_clientWhereUniqueInput>
    connect?: Enumerable<ship_clientWhereUniqueInput>
    update?: Enumerable<ship_clientUpdateWithWhereUniqueWithoutShipInput>
    updateMany?: Enumerable<ship_clientUpdateManyWithWhereWithoutShipInput>
    deleteMany?: Enumerable<ship_clientScalarWhereInput>
  }

  export type ship_marinerUpdateManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutShipInput>, Enumerable<ship_marinerUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutShipInput>
    upsert?: Enumerable<ship_marinerUpsertWithWhereUniqueWithoutShipInput>
    createMany?: ship_marinerCreateManyShipInputEnvelope
    set?: Enumerable<ship_marinerWhereUniqueInput>
    disconnect?: Enumerable<ship_marinerWhereUniqueInput>
    delete?: Enumerable<ship_marinerWhereUniqueInput>
    connect?: Enumerable<ship_marinerWhereUniqueInput>
    update?: Enumerable<ship_marinerUpdateWithWhereUniqueWithoutShipInput>
    updateMany?: Enumerable<ship_marinerUpdateManyWithWhereWithoutShipInput>
    deleteMany?: Enumerable<ship_marinerScalarWhereInput>
  }

  export type ship_clientUncheckedUpdateManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_clientCreateWithoutShipInput>, Enumerable<ship_clientUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_clientCreateOrConnectWithoutShipInput>
    upsert?: Enumerable<ship_clientUpsertWithWhereUniqueWithoutShipInput>
    createMany?: ship_clientCreateManyShipInputEnvelope
    set?: Enumerable<ship_clientWhereUniqueInput>
    disconnect?: Enumerable<ship_clientWhereUniqueInput>
    delete?: Enumerable<ship_clientWhereUniqueInput>
    connect?: Enumerable<ship_clientWhereUniqueInput>
    update?: Enumerable<ship_clientUpdateWithWhereUniqueWithoutShipInput>
    updateMany?: Enumerable<ship_clientUpdateManyWithWhereWithoutShipInput>
    deleteMany?: Enumerable<ship_clientScalarWhereInput>
  }

  export type ship_marinerUncheckedUpdateManyWithoutShipInput = {
    create?: XOR<Enumerable<ship_marinerCreateWithoutShipInput>, Enumerable<ship_marinerUncheckedCreateWithoutShipInput>>
    connectOrCreate?: Enumerable<ship_marinerCreateOrConnectWithoutShipInput>
    upsert?: Enumerable<ship_marinerUpsertWithWhereUniqueWithoutShipInput>
    createMany?: ship_marinerCreateManyShipInputEnvelope
    set?: Enumerable<ship_marinerWhereUniqueInput>
    disconnect?: Enumerable<ship_marinerWhereUniqueInput>
    delete?: Enumerable<ship_marinerWhereUniqueInput>
    connect?: Enumerable<ship_marinerWhereUniqueInput>
    update?: Enumerable<ship_marinerUpdateWithWhereUniqueWithoutShipInput>
    updateMany?: Enumerable<ship_marinerUpdateManyWithWhereWithoutShipInput>
    deleteMany?: Enumerable<ship_marinerScalarWhereInput>
  }

  export type marinerCreateNestedOneWithoutShip_marinerInput = {
    create?: XOR<marinerCreateWithoutShip_marinerInput, marinerUncheckedCreateWithoutShip_marinerInput>
    connectOrCreate?: marinerCreateOrConnectWithoutShip_marinerInput
    connect?: marinerWhereUniqueInput
  }

  export type shipCreateNestedOneWithoutShip_marinerInput = {
    create?: XOR<shipCreateWithoutShip_marinerInput, shipUncheckedCreateWithoutShip_marinerInput>
    connectOrCreate?: shipCreateOrConnectWithoutShip_marinerInput
    connect?: shipWhereUniqueInput
  }

  export type marinerUpdateOneRequiredWithoutShip_marinerInput = {
    create?: XOR<marinerCreateWithoutShip_marinerInput, marinerUncheckedCreateWithoutShip_marinerInput>
    connectOrCreate?: marinerCreateOrConnectWithoutShip_marinerInput
    upsert?: marinerUpsertWithoutShip_marinerInput
    connect?: marinerWhereUniqueInput
    update?: XOR<marinerUpdateWithoutShip_marinerInput, marinerUncheckedUpdateWithoutShip_marinerInput>
  }

  export type shipUpdateOneRequiredWithoutShip_marinerInput = {
    create?: XOR<shipCreateWithoutShip_marinerInput, shipUncheckedCreateWithoutShip_marinerInput>
    connectOrCreate?: shipCreateOrConnectWithoutShip_marinerInput
    upsert?: shipUpsertWithoutShip_marinerInput
    connect?: shipWhereUniqueInput
    update?: XOR<shipUpdateWithoutShip_marinerInput, shipUncheckedUpdateWithoutShip_marinerInput>
  }

  export type clientCreateNestedOneWithoutShip_clientInput = {
    create?: XOR<clientCreateWithoutShip_clientInput, clientUncheckedCreateWithoutShip_clientInput>
    connectOrCreate?: clientCreateOrConnectWithoutShip_clientInput
    connect?: clientWhereUniqueInput
  }

  export type shipCreateNestedOneWithoutShip_clientInput = {
    create?: XOR<shipCreateWithoutShip_clientInput, shipUncheckedCreateWithoutShip_clientInput>
    connectOrCreate?: shipCreateOrConnectWithoutShip_clientInput
    connect?: shipWhereUniqueInput
  }

  export type clientUpdateOneRequiredWithoutShip_clientInput = {
    create?: XOR<clientCreateWithoutShip_clientInput, clientUncheckedCreateWithoutShip_clientInput>
    connectOrCreate?: clientCreateOrConnectWithoutShip_clientInput
    upsert?: clientUpsertWithoutShip_clientInput
    connect?: clientWhereUniqueInput
    update?: XOR<clientUpdateWithoutShip_clientInput, clientUncheckedUpdateWithoutShip_clientInput>
  }

  export type shipUpdateOneRequiredWithoutShip_clientInput = {
    create?: XOR<shipCreateWithoutShip_clientInput, shipUncheckedCreateWithoutShip_clientInput>
    connectOrCreate?: shipCreateOrConnectWithoutShip_clientInput
    upsert?: shipUpsertWithoutShip_clientInput
    connect?: shipWhereUniqueInput
    update?: XOR<shipUpdateWithoutShip_clientInput, shipUncheckedUpdateWithoutShip_clientInput>
  }

  export type companyCreateNestedOneWithoutMovimentationInput = {
    create?: XOR<companyCreateWithoutMovimentationInput, companyUncheckedCreateWithoutMovimentationInput>
    connectOrCreate?: companyCreateOrConnectWithoutMovimentationInput
    connect?: companyWhereUniqueInput
  }

  export type move_statusCreateNestedOneWithoutMovimentationInput = {
    create?: XOR<move_statusCreateWithoutMovimentationInput, move_statusUncheckedCreateWithoutMovimentationInput>
    connectOrCreate?: move_statusCreateOrConnectWithoutMovimentationInput
    connect?: move_statusWhereUniqueInput
  }

  export type navagation_planCreateNestedOneWithoutMovimentationInput = {
    create?: XOR<navagation_planCreateWithoutMovimentationInput, navagation_planUncheckedCreateWithoutMovimentationInput>
    connectOrCreate?: navagation_planCreateOrConnectWithoutMovimentationInput
    connect?: navagation_planWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type companyUpdateOneRequiredWithoutMovimentationInput = {
    create?: XOR<companyCreateWithoutMovimentationInput, companyUncheckedCreateWithoutMovimentationInput>
    connectOrCreate?: companyCreateOrConnectWithoutMovimentationInput
    upsert?: companyUpsertWithoutMovimentationInput
    connect?: companyWhereUniqueInput
    update?: XOR<companyUpdateWithoutMovimentationInput, companyUncheckedUpdateWithoutMovimentationInput>
  }

  export type move_statusUpdateOneRequiredWithoutMovimentationInput = {
    create?: XOR<move_statusCreateWithoutMovimentationInput, move_statusUncheckedCreateWithoutMovimentationInput>
    connectOrCreate?: move_statusCreateOrConnectWithoutMovimentationInput
    upsert?: move_statusUpsertWithoutMovimentationInput
    connect?: move_statusWhereUniqueInput
    update?: XOR<move_statusUpdateWithoutMovimentationInput, move_statusUncheckedUpdateWithoutMovimentationInput>
  }

  export type navagation_planUpdateOneWithoutMovimentationInput = {
    create?: XOR<navagation_planCreateWithoutMovimentationInput, navagation_planUncheckedCreateWithoutMovimentationInput>
    connectOrCreate?: navagation_planCreateOrConnectWithoutMovimentationInput
    upsert?: navagation_planUpsertWithoutMovimentationInput
    disconnect?: boolean
    delete?: boolean
    connect?: navagation_planWhereUniqueInput
    update?: XOR<navagation_planUpdateWithoutMovimentationInput, navagation_planUncheckedUpdateWithoutMovimentationInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companyCreateNestedOneWithoutNavagation_planInput = {
    create?: XOR<companyCreateWithoutNavagation_planInput, companyUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: companyCreateOrConnectWithoutNavagation_planInput
    connect?: companyWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutNavagation_planInput = {
    create?: XOR<locationCreateWithoutNavagation_planInput, locationUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: locationCreateOrConnectWithoutNavagation_planInput
    connect?: locationWhereUniqueInput
  }

  export type move_statusCreateNestedOneWithoutNavagation_planInput = {
    create?: XOR<move_statusCreateWithoutNavagation_planInput, move_statusUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: move_statusCreateOrConnectWithoutNavagation_planInput
    connect?: move_statusWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutNavagation_planInput = {
    create?: XOR<usersCreateWithoutNavagation_planInput, usersUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: usersCreateOrConnectWithoutNavagation_planInput
    connect?: usersWhereUniqueInput
  }

  export type movimentationCreateNestedManyWithoutNavagation_planInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutNavagation_planInput>, Enumerable<movimentationUncheckedCreateWithoutNavagation_planInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutNavagation_planInput>
    createMany?: movimentationCreateManyNavagation_planInputEnvelope
    connect?: Enumerable<movimentationWhereUniqueInput>
  }

  export type movimentationUncheckedCreateNestedManyWithoutNavagation_planInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutNavagation_planInput>, Enumerable<movimentationUncheckedCreateWithoutNavagation_planInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutNavagation_planInput>
    createMany?: movimentationCreateManyNavagation_planInputEnvelope
    connect?: Enumerable<movimentationWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type companyUpdateOneRequiredWithoutNavagation_planInput = {
    create?: XOR<companyCreateWithoutNavagation_planInput, companyUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: companyCreateOrConnectWithoutNavagation_planInput
    upsert?: companyUpsertWithoutNavagation_planInput
    connect?: companyWhereUniqueInput
    update?: XOR<companyUpdateWithoutNavagation_planInput, companyUncheckedUpdateWithoutNavagation_planInput>
  }

  export type locationUpdateOneRequiredWithoutNavagation_planInput = {
    create?: XOR<locationCreateWithoutNavagation_planInput, locationUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: locationCreateOrConnectWithoutNavagation_planInput
    upsert?: locationUpsertWithoutNavagation_planInput
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutNavagation_planInput, locationUncheckedUpdateWithoutNavagation_planInput>
  }

  export type move_statusUpdateOneRequiredWithoutNavagation_planInput = {
    create?: XOR<move_statusCreateWithoutNavagation_planInput, move_statusUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: move_statusCreateOrConnectWithoutNavagation_planInput
    upsert?: move_statusUpsertWithoutNavagation_planInput
    connect?: move_statusWhereUniqueInput
    update?: XOR<move_statusUpdateWithoutNavagation_planInput, move_statusUncheckedUpdateWithoutNavagation_planInput>
  }

  export type usersUpdateOneRequiredWithoutNavagation_planInput = {
    create?: XOR<usersCreateWithoutNavagation_planInput, usersUncheckedCreateWithoutNavagation_planInput>
    connectOrCreate?: usersCreateOrConnectWithoutNavagation_planInput
    upsert?: usersUpsertWithoutNavagation_planInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutNavagation_planInput, usersUncheckedUpdateWithoutNavagation_planInput>
  }

  export type movimentationUpdateManyWithoutNavagation_planInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutNavagation_planInput>, Enumerable<movimentationUncheckedCreateWithoutNavagation_planInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutNavagation_planInput>
    upsert?: Enumerable<movimentationUpsertWithWhereUniqueWithoutNavagation_planInput>
    createMany?: movimentationCreateManyNavagation_planInputEnvelope
    set?: Enumerable<movimentationWhereUniqueInput>
    disconnect?: Enumerable<movimentationWhereUniqueInput>
    delete?: Enumerable<movimentationWhereUniqueInput>
    connect?: Enumerable<movimentationWhereUniqueInput>
    update?: Enumerable<movimentationUpdateWithWhereUniqueWithoutNavagation_planInput>
    updateMany?: Enumerable<movimentationUpdateManyWithWhereWithoutNavagation_planInput>
    deleteMany?: Enumerable<movimentationScalarWhereInput>
  }

  export type movimentationUncheckedUpdateManyWithoutNavagation_planInput = {
    create?: XOR<Enumerable<movimentationCreateWithoutNavagation_planInput>, Enumerable<movimentationUncheckedCreateWithoutNavagation_planInput>>
    connectOrCreate?: Enumerable<movimentationCreateOrConnectWithoutNavagation_planInput>
    upsert?: Enumerable<movimentationUpsertWithWhereUniqueWithoutNavagation_planInput>
    createMany?: movimentationCreateManyNavagation_planInputEnvelope
    set?: Enumerable<movimentationWhereUniqueInput>
    disconnect?: Enumerable<movimentationWhereUniqueInput>
    delete?: Enumerable<movimentationWhereUniqueInput>
    connect?: Enumerable<movimentationWhereUniqueInput>
    update?: Enumerable<movimentationUpdateWithWhereUniqueWithoutNavagation_planInput>
    updateMany?: Enumerable<movimentationUpdateManyWithWhereWithoutNavagation_planInput>
    deleteMany?: Enumerable<movimentationScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type companyCreateWithoutUsersInput = {
    ds_cnpj: string
    ds_name: string
    client?: clientCreateNestedManyWithoutCompanyInput
    location?: locationCreateNestedManyWithoutCompanyInput
    mariner?: marinerCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planCreateNestedManyWithoutCompanyInput
    ship?: shipCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutUsersInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    client?: clientUncheckedCreateNestedManyWithoutCompanyInput
    location?: locationUncheckedCreateNestedManyWithoutCompanyInput
    mariner?: marinerUncheckedCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationUncheckedCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutCompanyInput
    ship?: shipUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutUsersInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutUsersInput, companyUncheckedCreateWithoutUsersInput>
  }

  export type navagation_planCreateWithoutUserInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    Company: companyCreateNestedOneWithoutNavagation_planInput
    Location: locationCreateNestedOneWithoutNavagation_planInput
    MoveStaus: move_statusCreateNestedOneWithoutNavagation_planInput
    movimentation?: movimentationCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedCreateWithoutUserInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_company: number
    cd_move_status: number
    id_nav_plan?: number
    movimentation?: movimentationUncheckedCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planCreateOrConnectWithoutUserInput = {
    where: navagation_planWhereUniqueInput
    create: XOR<navagation_planCreateWithoutUserInput, navagation_planUncheckedCreateWithoutUserInput>
  }

  export type navagation_planCreateManyUserInputEnvelope = {
    data: Enumerable<navagation_planCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type companyUpsertWithoutUsersInput = {
    update: XOR<companyUpdateWithoutUsersInput, companyUncheckedUpdateWithoutUsersInput>
    create: XOR<companyCreateWithoutUsersInput, companyUncheckedCreateWithoutUsersInput>
  }

  export type companyUpdateWithoutUsersInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateManyWithoutCompanyInput
    location?: locationUpdateManyWithoutCompanyInput
    mariner?: marinerUpdateManyWithoutCompanyInput
    movimentation?: movimentationUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUpdateManyWithoutCompanyInput
    ship?: shipUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateWithoutUsersInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUncheckedUpdateManyWithoutCompanyInput
    location?: locationUncheckedUpdateManyWithoutCompanyInput
    mariner?: marinerUncheckedUpdateManyWithoutCompanyInput
    movimentation?: movimentationUncheckedUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutCompanyInput
    ship?: shipUncheckedUpdateManyWithoutCompanyInput
  }

  export type navagation_planUpsertWithWhereUniqueWithoutUserInput = {
    where: navagation_planWhereUniqueInput
    update: XOR<navagation_planUpdateWithoutUserInput, navagation_planUncheckedUpdateWithoutUserInput>
    create: XOR<navagation_planCreateWithoutUserInput, navagation_planUncheckedCreateWithoutUserInput>
  }

  export type navagation_planUpdateWithWhereUniqueWithoutUserInput = {
    where: navagation_planWhereUniqueInput
    data: XOR<navagation_planUpdateWithoutUserInput, navagation_planUncheckedUpdateWithoutUserInput>
  }

  export type navagation_planUpdateManyWithWhereWithoutUserInput = {
    where: navagation_planScalarWhereInput
    data: XOR<navagation_planUpdateManyMutationInput, navagation_planUncheckedUpdateManyWithoutNavagation_planInput>
  }

  export type navagation_planScalarWhereInput = {
    AND?: Enumerable<navagation_planScalarWhereInput>
    OR?: Enumerable<navagation_planScalarWhereInput>
    NOT?: Enumerable<navagation_planScalarWhereInput>
    qt_crew?: IntFilter | number
    qt_passengers?: IntFilter | number
    dt_departure?: DateTimeFilter | Date | string
    dt_arrival?: DateTimeNullableFilter | Date | string | null
    ds_observation?: StringNullableFilter | string | null
    cd_destiny?: IntFilter | number
    cd_user?: IntFilter | number
    cd_company?: IntFilter | number
    cd_move_status?: IntFilter | number
    id_nav_plan?: IntFilter | number
  }

  export type clientCreateWithoutCompanyInput = {
    ds_name: string
    ds_cpf: string
    ship_client?: ship_clientCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutCompanyInput = {
    id_client?: number
    ds_name: string
    ds_cpf: string
    ship_client?: ship_clientUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutCompanyInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutCompanyInput, clientUncheckedCreateWithoutCompanyInput>
  }

  export type clientCreateManyCompanyInputEnvelope = {
    data: Enumerable<clientCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type locationCreateWithoutCompanyInput = {
    ds_location: string
    navagation_plan?: navagation_planCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutCompanyInput = {
    id_location?: number
    ds_location: string
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutCompanyInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutCompanyInput, locationUncheckedCreateWithoutCompanyInput>
  }

  export type locationCreateManyCompanyInputEnvelope = {
    data: Enumerable<locationCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type marinerCreateWithoutCompanyInput = {
    ds_name: string
    ds_cpf: string
    ship_mariner?: ship_marinerCreateNestedManyWithoutMarinerInput
  }

  export type marinerUncheckedCreateWithoutCompanyInput = {
    id_mariner?: number
    ds_name: string
    ds_cpf: string
    ship_mariner?: ship_marinerUncheckedCreateNestedManyWithoutMarinerInput
  }

  export type marinerCreateOrConnectWithoutCompanyInput = {
    where: marinerWhereUniqueInput
    create: XOR<marinerCreateWithoutCompanyInput, marinerUncheckedCreateWithoutCompanyInput>
  }

  export type marinerCreateManyCompanyInputEnvelope = {
    data: Enumerable<marinerCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type movimentationCreateWithoutCompanyInput = {
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    move_staus: move_statusCreateNestedOneWithoutMovimentationInput
    navagation_plan?: navagation_planCreateNestedOneWithoutMovimentationInput
  }

  export type movimentationUncheckedCreateWithoutCompanyInput = {
    id_movimentation?: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_move_status: number
    cd_nav_plan?: number | null
  }

  export type movimentationCreateOrConnectWithoutCompanyInput = {
    where: movimentationWhereUniqueInput
    create: XOR<movimentationCreateWithoutCompanyInput, movimentationUncheckedCreateWithoutCompanyInput>
  }

  export type movimentationCreateManyCompanyInputEnvelope = {
    data: Enumerable<movimentationCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type navagation_planCreateWithoutCompanyInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    Location: locationCreateNestedOneWithoutNavagation_planInput
    MoveStaus: move_statusCreateNestedOneWithoutNavagation_planInput
    User: usersCreateNestedOneWithoutNavagation_planInput
    movimentation?: movimentationCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedCreateWithoutCompanyInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_user: number
    cd_move_status: number
    id_nav_plan?: number
    movimentation?: movimentationUncheckedCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planCreateOrConnectWithoutCompanyInput = {
    where: navagation_planWhereUniqueInput
    create: XOR<navagation_planCreateWithoutCompanyInput, navagation_planUncheckedCreateWithoutCompanyInput>
  }

  export type navagation_planCreateManyCompanyInputEnvelope = {
    data: Enumerable<navagation_planCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type shipCreateWithoutCompanyInput = {
    ds_ship: string
    ship_client?: ship_clientCreateNestedManyWithoutShipInput
    ship_mariner?: ship_marinerCreateNestedManyWithoutShipInput
  }

  export type shipUncheckedCreateWithoutCompanyInput = {
    id_ship?: number
    ds_ship: string
    ship_client?: ship_clientUncheckedCreateNestedManyWithoutShipInput
    ship_mariner?: ship_marinerUncheckedCreateNestedManyWithoutShipInput
  }

  export type shipCreateOrConnectWithoutCompanyInput = {
    where: shipWhereUniqueInput
    create: XOR<shipCreateWithoutCompanyInput, shipUncheckedCreateWithoutCompanyInput>
  }

  export type shipCreateManyCompanyInputEnvelope = {
    data: Enumerable<shipCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutCompanyInput = {
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
    navagation_plan?: navagation_planCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutCompanyInput = {
    id_user?: number
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutCompanyInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCompanyInput, usersUncheckedCreateWithoutCompanyInput>
  }

  export type usersCreateManyCompanyInputEnvelope = {
    data: Enumerable<usersCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type clientUpsertWithWhereUniqueWithoutCompanyInput = {
    where: clientWhereUniqueInput
    update: XOR<clientUpdateWithoutCompanyInput, clientUncheckedUpdateWithoutCompanyInput>
    create: XOR<clientCreateWithoutCompanyInput, clientUncheckedCreateWithoutCompanyInput>
  }

  export type clientUpdateWithWhereUniqueWithoutCompanyInput = {
    where: clientWhereUniqueInput
    data: XOR<clientUpdateWithoutCompanyInput, clientUncheckedUpdateWithoutCompanyInput>
  }

  export type clientUpdateManyWithWhereWithoutCompanyInput = {
    where: clientScalarWhereInput
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyWithoutClientInput>
  }

  export type clientScalarWhereInput = {
    AND?: Enumerable<clientScalarWhereInput>
    OR?: Enumerable<clientScalarWhereInput>
    NOT?: Enumerable<clientScalarWhereInput>
    id_client?: IntFilter | number
    ds_name?: StringFilter | string
    ds_cpf?: StringFilter | string
    cd_company?: IntFilter | number
  }

  export type locationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: locationWhereUniqueInput
    update: XOR<locationUpdateWithoutCompanyInput, locationUncheckedUpdateWithoutCompanyInput>
    create: XOR<locationCreateWithoutCompanyInput, locationUncheckedCreateWithoutCompanyInput>
  }

  export type locationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: locationWhereUniqueInput
    data: XOR<locationUpdateWithoutCompanyInput, locationUncheckedUpdateWithoutCompanyInput>
  }

  export type locationUpdateManyWithWhereWithoutCompanyInput = {
    where: locationScalarWhereInput
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyWithoutLocationInput>
  }

  export type locationScalarWhereInput = {
    AND?: Enumerable<locationScalarWhereInput>
    OR?: Enumerable<locationScalarWhereInput>
    NOT?: Enumerable<locationScalarWhereInput>
    id_location?: IntFilter | number
    ds_location?: StringFilter | string
    cd_company?: IntFilter | number
  }

  export type marinerUpsertWithWhereUniqueWithoutCompanyInput = {
    where: marinerWhereUniqueInput
    update: XOR<marinerUpdateWithoutCompanyInput, marinerUncheckedUpdateWithoutCompanyInput>
    create: XOR<marinerCreateWithoutCompanyInput, marinerUncheckedCreateWithoutCompanyInput>
  }

  export type marinerUpdateWithWhereUniqueWithoutCompanyInput = {
    where: marinerWhereUniqueInput
    data: XOR<marinerUpdateWithoutCompanyInput, marinerUncheckedUpdateWithoutCompanyInput>
  }

  export type marinerUpdateManyWithWhereWithoutCompanyInput = {
    where: marinerScalarWhereInput
    data: XOR<marinerUpdateManyMutationInput, marinerUncheckedUpdateManyWithoutMarinerInput>
  }

  export type marinerScalarWhereInput = {
    AND?: Enumerable<marinerScalarWhereInput>
    OR?: Enumerable<marinerScalarWhereInput>
    NOT?: Enumerable<marinerScalarWhereInput>
    id_mariner?: IntFilter | number
    ds_name?: StringFilter | string
    ds_cpf?: StringFilter | string
    cd_company?: IntFilter | number
  }

  export type movimentationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: movimentationWhereUniqueInput
    update: XOR<movimentationUpdateWithoutCompanyInput, movimentationUncheckedUpdateWithoutCompanyInput>
    create: XOR<movimentationCreateWithoutCompanyInput, movimentationUncheckedCreateWithoutCompanyInput>
  }

  export type movimentationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: movimentationWhereUniqueInput
    data: XOR<movimentationUpdateWithoutCompanyInput, movimentationUncheckedUpdateWithoutCompanyInput>
  }

  export type movimentationUpdateManyWithWhereWithoutCompanyInput = {
    where: movimentationScalarWhereInput
    data: XOR<movimentationUpdateManyMutationInput, movimentationUncheckedUpdateManyWithoutMovimentationInput>
  }

  export type movimentationScalarWhereInput = {
    AND?: Enumerable<movimentationScalarWhereInput>
    OR?: Enumerable<movimentationScalarWhereInput>
    NOT?: Enumerable<movimentationScalarWhereInput>
    id_movimentation?: IntFilter | number
    cd_company?: IntFilter | number
    dt_finished?: DateTimeNullableFilter | Date | string | null
    dt_opned?: DateTimeFilter | Date | string
    id_finished?: BoolFilter | boolean
    cd_move_status?: IntFilter | number
    cd_nav_plan?: IntNullableFilter | number | null
  }

  export type navagation_planUpsertWithWhereUniqueWithoutCompanyInput = {
    where: navagation_planWhereUniqueInput
    update: XOR<navagation_planUpdateWithoutCompanyInput, navagation_planUncheckedUpdateWithoutCompanyInput>
    create: XOR<navagation_planCreateWithoutCompanyInput, navagation_planUncheckedCreateWithoutCompanyInput>
  }

  export type navagation_planUpdateWithWhereUniqueWithoutCompanyInput = {
    where: navagation_planWhereUniqueInput
    data: XOR<navagation_planUpdateWithoutCompanyInput, navagation_planUncheckedUpdateWithoutCompanyInput>
  }

  export type navagation_planUpdateManyWithWhereWithoutCompanyInput = {
    where: navagation_planScalarWhereInput
    data: XOR<navagation_planUpdateManyMutationInput, navagation_planUncheckedUpdateManyWithoutNavagation_planInput>
  }

  export type shipUpsertWithWhereUniqueWithoutCompanyInput = {
    where: shipWhereUniqueInput
    update: XOR<shipUpdateWithoutCompanyInput, shipUncheckedUpdateWithoutCompanyInput>
    create: XOR<shipCreateWithoutCompanyInput, shipUncheckedCreateWithoutCompanyInput>
  }

  export type shipUpdateWithWhereUniqueWithoutCompanyInput = {
    where: shipWhereUniqueInput
    data: XOR<shipUpdateWithoutCompanyInput, shipUncheckedUpdateWithoutCompanyInput>
  }

  export type shipUpdateManyWithWhereWithoutCompanyInput = {
    where: shipScalarWhereInput
    data: XOR<shipUpdateManyMutationInput, shipUncheckedUpdateManyWithoutShipInput>
  }

  export type shipScalarWhereInput = {
    AND?: Enumerable<shipScalarWhereInput>
    OR?: Enumerable<shipScalarWhereInput>
    NOT?: Enumerable<shipScalarWhereInput>
    id_ship?: IntFilter | number
    ds_ship?: StringFilter | string
    cd_company?: IntFilter | number
  }

  export type usersUpsertWithWhereUniqueWithoutCompanyInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutCompanyInput, usersUncheckedUpdateWithoutCompanyInput>
    create: XOR<usersCreateWithoutCompanyInput, usersUncheckedCreateWithoutCompanyInput>
  }

  export type usersUpdateWithWhereUniqueWithoutCompanyInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutCompanyInput, usersUncheckedUpdateWithoutCompanyInput>
  }

  export type usersUpdateManyWithWhereWithoutCompanyInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersScalarWhereInput = {
    AND?: Enumerable<usersScalarWhereInput>
    OR?: Enumerable<usersScalarWhereInput>
    NOT?: Enumerable<usersScalarWhereInput>
    id_user?: IntFilter | number
    cd_company?: IntFilter | number
    ds_email?: StringFilter | string
    ds_name?: StringFilter | string
    ds_password?: StringFilter | string
    id_manager?: BoolFilter | boolean
    id_operational?: BoolFilter | boolean
    id_operator?: BoolFilter | boolean
  }

  export type companyCreateWithoutLocationInput = {
    ds_cnpj: string
    ds_name: string
    client?: clientCreateNestedManyWithoutCompanyInput
    mariner?: marinerCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planCreateNestedManyWithoutCompanyInput
    ship?: shipCreateNestedManyWithoutCompanyInput
    users?: usersCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutLocationInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    client?: clientUncheckedCreateNestedManyWithoutCompanyInput
    mariner?: marinerUncheckedCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationUncheckedCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutCompanyInput
    ship?: shipUncheckedCreateNestedManyWithoutCompanyInput
    users?: usersUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutLocationInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutLocationInput, companyUncheckedCreateWithoutLocationInput>
  }

  export type navagation_planCreateWithoutLocationInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    Company: companyCreateNestedOneWithoutNavagation_planInput
    MoveStaus: move_statusCreateNestedOneWithoutNavagation_planInput
    User: usersCreateNestedOneWithoutNavagation_planInput
    movimentation?: movimentationCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedCreateWithoutLocationInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_user: number
    cd_company: number
    cd_move_status: number
    id_nav_plan?: number
    movimentation?: movimentationUncheckedCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planCreateOrConnectWithoutLocationInput = {
    where: navagation_planWhereUniqueInput
    create: XOR<navagation_planCreateWithoutLocationInput, navagation_planUncheckedCreateWithoutLocationInput>
  }

  export type navagation_planCreateManyLocationInputEnvelope = {
    data: Enumerable<navagation_planCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type companyUpsertWithoutLocationInput = {
    update: XOR<companyUpdateWithoutLocationInput, companyUncheckedUpdateWithoutLocationInput>
    create: XOR<companyCreateWithoutLocationInput, companyUncheckedCreateWithoutLocationInput>
  }

  export type companyUpdateWithoutLocationInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateManyWithoutCompanyInput
    mariner?: marinerUpdateManyWithoutCompanyInput
    movimentation?: movimentationUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUpdateManyWithoutCompanyInput
    ship?: shipUpdateManyWithoutCompanyInput
    users?: usersUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateWithoutLocationInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUncheckedUpdateManyWithoutCompanyInput
    mariner?: marinerUncheckedUpdateManyWithoutCompanyInput
    movimentation?: movimentationUncheckedUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutCompanyInput
    ship?: shipUncheckedUpdateManyWithoutCompanyInput
    users?: usersUncheckedUpdateManyWithoutCompanyInput
  }

  export type navagation_planUpsertWithWhereUniqueWithoutLocationInput = {
    where: navagation_planWhereUniqueInput
    update: XOR<navagation_planUpdateWithoutLocationInput, navagation_planUncheckedUpdateWithoutLocationInput>
    create: XOR<navagation_planCreateWithoutLocationInput, navagation_planUncheckedCreateWithoutLocationInput>
  }

  export type navagation_planUpdateWithWhereUniqueWithoutLocationInput = {
    where: navagation_planWhereUniqueInput
    data: XOR<navagation_planUpdateWithoutLocationInput, navagation_planUncheckedUpdateWithoutLocationInput>
  }

  export type navagation_planUpdateManyWithWhereWithoutLocationInput = {
    where: navagation_planScalarWhereInput
    data: XOR<navagation_planUpdateManyMutationInput, navagation_planUncheckedUpdateManyWithoutNavagation_planInput>
  }

  export type movimentationCreateWithoutMove_stausInput = {
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    Company: companyCreateNestedOneWithoutMovimentationInput
    navagation_plan?: navagation_planCreateNestedOneWithoutMovimentationInput
  }

  export type movimentationUncheckedCreateWithoutMove_stausInput = {
    id_movimentation?: number
    cd_company: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_nav_plan?: number | null
  }

  export type movimentationCreateOrConnectWithoutMove_stausInput = {
    where: movimentationWhereUniqueInput
    create: XOR<movimentationCreateWithoutMove_stausInput, movimentationUncheckedCreateWithoutMove_stausInput>
  }

  export type movimentationCreateManyMove_stausInputEnvelope = {
    data: Enumerable<movimentationCreateManyMove_stausInput>
    skipDuplicates?: boolean
  }

  export type navagation_planCreateWithoutMoveStausInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    Company: companyCreateNestedOneWithoutNavagation_planInput
    Location: locationCreateNestedOneWithoutNavagation_planInput
    User: usersCreateNestedOneWithoutNavagation_planInput
    movimentation?: movimentationCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedCreateWithoutMoveStausInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_user: number
    cd_company: number
    id_nav_plan?: number
    movimentation?: movimentationUncheckedCreateNestedManyWithoutNavagation_planInput
  }

  export type navagation_planCreateOrConnectWithoutMoveStausInput = {
    where: navagation_planWhereUniqueInput
    create: XOR<navagation_planCreateWithoutMoveStausInput, navagation_planUncheckedCreateWithoutMoveStausInput>
  }

  export type navagation_planCreateManyMoveStausInputEnvelope = {
    data: Enumerable<navagation_planCreateManyMoveStausInput>
    skipDuplicates?: boolean
  }

  export type movimentationUpsertWithWhereUniqueWithoutMove_stausInput = {
    where: movimentationWhereUniqueInput
    update: XOR<movimentationUpdateWithoutMove_stausInput, movimentationUncheckedUpdateWithoutMove_stausInput>
    create: XOR<movimentationCreateWithoutMove_stausInput, movimentationUncheckedCreateWithoutMove_stausInput>
  }

  export type movimentationUpdateWithWhereUniqueWithoutMove_stausInput = {
    where: movimentationWhereUniqueInput
    data: XOR<movimentationUpdateWithoutMove_stausInput, movimentationUncheckedUpdateWithoutMove_stausInput>
  }

  export type movimentationUpdateManyWithWhereWithoutMove_stausInput = {
    where: movimentationScalarWhereInput
    data: XOR<movimentationUpdateManyMutationInput, movimentationUncheckedUpdateManyWithoutMovimentationInput>
  }

  export type navagation_planUpsertWithWhereUniqueWithoutMoveStausInput = {
    where: navagation_planWhereUniqueInput
    update: XOR<navagation_planUpdateWithoutMoveStausInput, navagation_planUncheckedUpdateWithoutMoveStausInput>
    create: XOR<navagation_planCreateWithoutMoveStausInput, navagation_planUncheckedCreateWithoutMoveStausInput>
  }

  export type navagation_planUpdateWithWhereUniqueWithoutMoveStausInput = {
    where: navagation_planWhereUniqueInput
    data: XOR<navagation_planUpdateWithoutMoveStausInput, navagation_planUncheckedUpdateWithoutMoveStausInput>
  }

  export type navagation_planUpdateManyWithWhereWithoutMoveStausInput = {
    where: navagation_planScalarWhereInput
    data: XOR<navagation_planUpdateManyMutationInput, navagation_planUncheckedUpdateManyWithoutNavagation_planInput>
  }

  export type companyCreateWithoutClientInput = {
    ds_cnpj: string
    ds_name: string
    location?: locationCreateNestedManyWithoutCompanyInput
    mariner?: marinerCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planCreateNestedManyWithoutCompanyInput
    ship?: shipCreateNestedManyWithoutCompanyInput
    users?: usersCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutClientInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    location?: locationUncheckedCreateNestedManyWithoutCompanyInput
    mariner?: marinerUncheckedCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationUncheckedCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutCompanyInput
    ship?: shipUncheckedCreateNestedManyWithoutCompanyInput
    users?: usersUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutClientInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutClientInput, companyUncheckedCreateWithoutClientInput>
  }

  export type ship_clientCreateWithoutClientInput = {
    Ship: shipCreateNestedOneWithoutShip_clientInput
  }

  export type ship_clientUncheckedCreateWithoutClientInput = {
    cd_ship: number
    id_cliente_mariner?: number
  }

  export type ship_clientCreateOrConnectWithoutClientInput = {
    where: ship_clientWhereUniqueInput
    create: XOR<ship_clientCreateWithoutClientInput, ship_clientUncheckedCreateWithoutClientInput>
  }

  export type ship_clientCreateManyClientInputEnvelope = {
    data: Enumerable<ship_clientCreateManyClientInput>
    skipDuplicates?: boolean
  }

  export type companyUpsertWithoutClientInput = {
    update: XOR<companyUpdateWithoutClientInput, companyUncheckedUpdateWithoutClientInput>
    create: XOR<companyCreateWithoutClientInput, companyUncheckedCreateWithoutClientInput>
  }

  export type companyUpdateWithoutClientInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    location?: locationUpdateManyWithoutCompanyInput
    mariner?: marinerUpdateManyWithoutCompanyInput
    movimentation?: movimentationUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUpdateManyWithoutCompanyInput
    ship?: shipUpdateManyWithoutCompanyInput
    users?: usersUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateWithoutClientInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    location?: locationUncheckedUpdateManyWithoutCompanyInput
    mariner?: marinerUncheckedUpdateManyWithoutCompanyInput
    movimentation?: movimentationUncheckedUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutCompanyInput
    ship?: shipUncheckedUpdateManyWithoutCompanyInput
    users?: usersUncheckedUpdateManyWithoutCompanyInput
  }

  export type ship_clientUpsertWithWhereUniqueWithoutClientInput = {
    where: ship_clientWhereUniqueInput
    update: XOR<ship_clientUpdateWithoutClientInput, ship_clientUncheckedUpdateWithoutClientInput>
    create: XOR<ship_clientCreateWithoutClientInput, ship_clientUncheckedCreateWithoutClientInput>
  }

  export type ship_clientUpdateWithWhereUniqueWithoutClientInput = {
    where: ship_clientWhereUniqueInput
    data: XOR<ship_clientUpdateWithoutClientInput, ship_clientUncheckedUpdateWithoutClientInput>
  }

  export type ship_clientUpdateManyWithWhereWithoutClientInput = {
    where: ship_clientScalarWhereInput
    data: XOR<ship_clientUpdateManyMutationInput, ship_clientUncheckedUpdateManyWithoutShip_clientInput>
  }

  export type ship_clientScalarWhereInput = {
    AND?: Enumerable<ship_clientScalarWhereInput>
    OR?: Enumerable<ship_clientScalarWhereInput>
    NOT?: Enumerable<ship_clientScalarWhereInput>
    cd_ship?: IntFilter | number
    cd_client?: IntFilter | number
    id_cliente_mariner?: IntFilter | number
  }

  export type companyCreateWithoutMarinerInput = {
    ds_cnpj: string
    ds_name: string
    client?: clientCreateNestedManyWithoutCompanyInput
    location?: locationCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planCreateNestedManyWithoutCompanyInput
    ship?: shipCreateNestedManyWithoutCompanyInput
    users?: usersCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutMarinerInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    client?: clientUncheckedCreateNestedManyWithoutCompanyInput
    location?: locationUncheckedCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationUncheckedCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutCompanyInput
    ship?: shipUncheckedCreateNestedManyWithoutCompanyInput
    users?: usersUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutMarinerInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutMarinerInput, companyUncheckedCreateWithoutMarinerInput>
  }

  export type ship_marinerCreateWithoutMarinerInput = {
    Ship: shipCreateNestedOneWithoutShip_marinerInput
  }

  export type ship_marinerUncheckedCreateWithoutMarinerInput = {
    cd_ship: number
    id_cliente_mariner?: number
  }

  export type ship_marinerCreateOrConnectWithoutMarinerInput = {
    where: ship_marinerWhereUniqueInput
    create: XOR<ship_marinerCreateWithoutMarinerInput, ship_marinerUncheckedCreateWithoutMarinerInput>
  }

  export type ship_marinerCreateManyMarinerInputEnvelope = {
    data: Enumerable<ship_marinerCreateManyMarinerInput>
    skipDuplicates?: boolean
  }

  export type companyUpsertWithoutMarinerInput = {
    update: XOR<companyUpdateWithoutMarinerInput, companyUncheckedUpdateWithoutMarinerInput>
    create: XOR<companyCreateWithoutMarinerInput, companyUncheckedCreateWithoutMarinerInput>
  }

  export type companyUpdateWithoutMarinerInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateManyWithoutCompanyInput
    location?: locationUpdateManyWithoutCompanyInput
    movimentation?: movimentationUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUpdateManyWithoutCompanyInput
    ship?: shipUpdateManyWithoutCompanyInput
    users?: usersUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateWithoutMarinerInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUncheckedUpdateManyWithoutCompanyInput
    location?: locationUncheckedUpdateManyWithoutCompanyInput
    movimentation?: movimentationUncheckedUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutCompanyInput
    ship?: shipUncheckedUpdateManyWithoutCompanyInput
    users?: usersUncheckedUpdateManyWithoutCompanyInput
  }

  export type ship_marinerUpsertWithWhereUniqueWithoutMarinerInput = {
    where: ship_marinerWhereUniqueInput
    update: XOR<ship_marinerUpdateWithoutMarinerInput, ship_marinerUncheckedUpdateWithoutMarinerInput>
    create: XOR<ship_marinerCreateWithoutMarinerInput, ship_marinerUncheckedCreateWithoutMarinerInput>
  }

  export type ship_marinerUpdateWithWhereUniqueWithoutMarinerInput = {
    where: ship_marinerWhereUniqueInput
    data: XOR<ship_marinerUpdateWithoutMarinerInput, ship_marinerUncheckedUpdateWithoutMarinerInput>
  }

  export type ship_marinerUpdateManyWithWhereWithoutMarinerInput = {
    where: ship_marinerScalarWhereInput
    data: XOR<ship_marinerUpdateManyMutationInput, ship_marinerUncheckedUpdateManyWithoutShip_marinerInput>
  }

  export type ship_marinerScalarWhereInput = {
    AND?: Enumerable<ship_marinerScalarWhereInput>
    OR?: Enumerable<ship_marinerScalarWhereInput>
    NOT?: Enumerable<ship_marinerScalarWhereInput>
    cd_ship?: IntFilter | number
    cd_mariner?: IntFilter | number
    id_cliente_mariner?: IntFilter | number
  }

  export type companyCreateWithoutShipInput = {
    ds_cnpj: string
    ds_name: string
    client?: clientCreateNestedManyWithoutCompanyInput
    location?: locationCreateNestedManyWithoutCompanyInput
    mariner?: marinerCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planCreateNestedManyWithoutCompanyInput
    users?: usersCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutShipInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    client?: clientUncheckedCreateNestedManyWithoutCompanyInput
    location?: locationUncheckedCreateNestedManyWithoutCompanyInput
    mariner?: marinerUncheckedCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationUncheckedCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutCompanyInput
    users?: usersUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutShipInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutShipInput, companyUncheckedCreateWithoutShipInput>
  }

  export type ship_clientCreateWithoutShipInput = {
    Client: clientCreateNestedOneWithoutShip_clientInput
  }

  export type ship_clientUncheckedCreateWithoutShipInput = {
    cd_client: number
    id_cliente_mariner?: number
  }

  export type ship_clientCreateOrConnectWithoutShipInput = {
    where: ship_clientWhereUniqueInput
    create: XOR<ship_clientCreateWithoutShipInput, ship_clientUncheckedCreateWithoutShipInput>
  }

  export type ship_clientCreateManyShipInputEnvelope = {
    data: Enumerable<ship_clientCreateManyShipInput>
    skipDuplicates?: boolean
  }

  export type ship_marinerCreateWithoutShipInput = {
    Mariner: marinerCreateNestedOneWithoutShip_marinerInput
  }

  export type ship_marinerUncheckedCreateWithoutShipInput = {
    cd_mariner: number
    id_cliente_mariner?: number
  }

  export type ship_marinerCreateOrConnectWithoutShipInput = {
    where: ship_marinerWhereUniqueInput
    create: XOR<ship_marinerCreateWithoutShipInput, ship_marinerUncheckedCreateWithoutShipInput>
  }

  export type ship_marinerCreateManyShipInputEnvelope = {
    data: Enumerable<ship_marinerCreateManyShipInput>
    skipDuplicates?: boolean
  }

  export type companyUpsertWithoutShipInput = {
    update: XOR<companyUpdateWithoutShipInput, companyUncheckedUpdateWithoutShipInput>
    create: XOR<companyCreateWithoutShipInput, companyUncheckedCreateWithoutShipInput>
  }

  export type companyUpdateWithoutShipInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateManyWithoutCompanyInput
    location?: locationUpdateManyWithoutCompanyInput
    mariner?: marinerUpdateManyWithoutCompanyInput
    movimentation?: movimentationUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUpdateManyWithoutCompanyInput
    users?: usersUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateWithoutShipInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUncheckedUpdateManyWithoutCompanyInput
    location?: locationUncheckedUpdateManyWithoutCompanyInput
    mariner?: marinerUncheckedUpdateManyWithoutCompanyInput
    movimentation?: movimentationUncheckedUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutCompanyInput
    users?: usersUncheckedUpdateManyWithoutCompanyInput
  }

  export type ship_clientUpsertWithWhereUniqueWithoutShipInput = {
    where: ship_clientWhereUniqueInput
    update: XOR<ship_clientUpdateWithoutShipInput, ship_clientUncheckedUpdateWithoutShipInput>
    create: XOR<ship_clientCreateWithoutShipInput, ship_clientUncheckedCreateWithoutShipInput>
  }

  export type ship_clientUpdateWithWhereUniqueWithoutShipInput = {
    where: ship_clientWhereUniqueInput
    data: XOR<ship_clientUpdateWithoutShipInput, ship_clientUncheckedUpdateWithoutShipInput>
  }

  export type ship_clientUpdateManyWithWhereWithoutShipInput = {
    where: ship_clientScalarWhereInput
    data: XOR<ship_clientUpdateManyMutationInput, ship_clientUncheckedUpdateManyWithoutShip_clientInput>
  }

  export type ship_marinerUpsertWithWhereUniqueWithoutShipInput = {
    where: ship_marinerWhereUniqueInput
    update: XOR<ship_marinerUpdateWithoutShipInput, ship_marinerUncheckedUpdateWithoutShipInput>
    create: XOR<ship_marinerCreateWithoutShipInput, ship_marinerUncheckedCreateWithoutShipInput>
  }

  export type ship_marinerUpdateWithWhereUniqueWithoutShipInput = {
    where: ship_marinerWhereUniqueInput
    data: XOR<ship_marinerUpdateWithoutShipInput, ship_marinerUncheckedUpdateWithoutShipInput>
  }

  export type ship_marinerUpdateManyWithWhereWithoutShipInput = {
    where: ship_marinerScalarWhereInput
    data: XOR<ship_marinerUpdateManyMutationInput, ship_marinerUncheckedUpdateManyWithoutShip_marinerInput>
  }

  export type marinerCreateWithoutShip_marinerInput = {
    ds_name: string
    ds_cpf: string
    Company: companyCreateNestedOneWithoutMarinerInput
  }

  export type marinerUncheckedCreateWithoutShip_marinerInput = {
    id_mariner?: number
    ds_name: string
    ds_cpf: string
    cd_company: number
  }

  export type marinerCreateOrConnectWithoutShip_marinerInput = {
    where: marinerWhereUniqueInput
    create: XOR<marinerCreateWithoutShip_marinerInput, marinerUncheckedCreateWithoutShip_marinerInput>
  }

  export type shipCreateWithoutShip_marinerInput = {
    ds_ship: string
    Company: companyCreateNestedOneWithoutShipInput
    ship_client?: ship_clientCreateNestedManyWithoutShipInput
  }

  export type shipUncheckedCreateWithoutShip_marinerInput = {
    id_ship?: number
    ds_ship: string
    cd_company: number
    ship_client?: ship_clientUncheckedCreateNestedManyWithoutShipInput
  }

  export type shipCreateOrConnectWithoutShip_marinerInput = {
    where: shipWhereUniqueInput
    create: XOR<shipCreateWithoutShip_marinerInput, shipUncheckedCreateWithoutShip_marinerInput>
  }

  export type marinerUpsertWithoutShip_marinerInput = {
    update: XOR<marinerUpdateWithoutShip_marinerInput, marinerUncheckedUpdateWithoutShip_marinerInput>
    create: XOR<marinerCreateWithoutShip_marinerInput, marinerUncheckedCreateWithoutShip_marinerInput>
  }

  export type marinerUpdateWithoutShip_marinerInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutMarinerInput
  }

  export type marinerUncheckedUpdateWithoutShip_marinerInput = {
    id_mariner?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
  }

  export type shipUpsertWithoutShip_marinerInput = {
    update: XOR<shipUpdateWithoutShip_marinerInput, shipUncheckedUpdateWithoutShip_marinerInput>
    create: XOR<shipCreateWithoutShip_marinerInput, shipUncheckedCreateWithoutShip_marinerInput>
  }

  export type shipUpdateWithoutShip_marinerInput = {
    ds_ship?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutShipInput
    ship_client?: ship_clientUpdateManyWithoutShipInput
  }

  export type shipUncheckedUpdateWithoutShip_marinerInput = {
    id_ship?: IntFieldUpdateOperationsInput | number
    ds_ship?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
    ship_client?: ship_clientUncheckedUpdateManyWithoutShipInput
  }

  export type clientCreateWithoutShip_clientInput = {
    ds_name: string
    ds_cpf: string
    Company: companyCreateNestedOneWithoutClientInput
  }

  export type clientUncheckedCreateWithoutShip_clientInput = {
    id_client?: number
    ds_name: string
    ds_cpf: string
    cd_company: number
  }

  export type clientCreateOrConnectWithoutShip_clientInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutShip_clientInput, clientUncheckedCreateWithoutShip_clientInput>
  }

  export type shipCreateWithoutShip_clientInput = {
    ds_ship: string
    Company: companyCreateNestedOneWithoutShipInput
    ship_mariner?: ship_marinerCreateNestedManyWithoutShipInput
  }

  export type shipUncheckedCreateWithoutShip_clientInput = {
    id_ship?: number
    ds_ship: string
    cd_company: number
    ship_mariner?: ship_marinerUncheckedCreateNestedManyWithoutShipInput
  }

  export type shipCreateOrConnectWithoutShip_clientInput = {
    where: shipWhereUniqueInput
    create: XOR<shipCreateWithoutShip_clientInput, shipUncheckedCreateWithoutShip_clientInput>
  }

  export type clientUpsertWithoutShip_clientInput = {
    update: XOR<clientUpdateWithoutShip_clientInput, clientUncheckedUpdateWithoutShip_clientInput>
    create: XOR<clientCreateWithoutShip_clientInput, clientUncheckedCreateWithoutShip_clientInput>
  }

  export type clientUpdateWithoutShip_clientInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutClientInput
  }

  export type clientUncheckedUpdateWithoutShip_clientInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
  }

  export type shipUpsertWithoutShip_clientInput = {
    update: XOR<shipUpdateWithoutShip_clientInput, shipUncheckedUpdateWithoutShip_clientInput>
    create: XOR<shipCreateWithoutShip_clientInput, shipUncheckedCreateWithoutShip_clientInput>
  }

  export type shipUpdateWithoutShip_clientInput = {
    ds_ship?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutShipInput
    ship_mariner?: ship_marinerUpdateManyWithoutShipInput
  }

  export type shipUncheckedUpdateWithoutShip_clientInput = {
    id_ship?: IntFieldUpdateOperationsInput | number
    ds_ship?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
    ship_mariner?: ship_marinerUncheckedUpdateManyWithoutShipInput
  }

  export type companyCreateWithoutMovimentationInput = {
    ds_cnpj: string
    ds_name: string
    client?: clientCreateNestedManyWithoutCompanyInput
    location?: locationCreateNestedManyWithoutCompanyInput
    mariner?: marinerCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planCreateNestedManyWithoutCompanyInput
    ship?: shipCreateNestedManyWithoutCompanyInput
    users?: usersCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutMovimentationInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    client?: clientUncheckedCreateNestedManyWithoutCompanyInput
    location?: locationUncheckedCreateNestedManyWithoutCompanyInput
    mariner?: marinerUncheckedCreateNestedManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutCompanyInput
    ship?: shipUncheckedCreateNestedManyWithoutCompanyInput
    users?: usersUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutMovimentationInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutMovimentationInput, companyUncheckedCreateWithoutMovimentationInput>
  }

  export type move_statusCreateWithoutMovimentationInput = {
    ds_status: string
    navagation_plan?: navagation_planCreateNestedManyWithoutMoveStausInput
  }

  export type move_statusUncheckedCreateWithoutMovimentationInput = {
    id_status?: number
    ds_status: string
    navagation_plan?: navagation_planUncheckedCreateNestedManyWithoutMoveStausInput
  }

  export type move_statusCreateOrConnectWithoutMovimentationInput = {
    where: move_statusWhereUniqueInput
    create: XOR<move_statusCreateWithoutMovimentationInput, move_statusUncheckedCreateWithoutMovimentationInput>
  }

  export type navagation_planCreateWithoutMovimentationInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    Company: companyCreateNestedOneWithoutNavagation_planInput
    Location: locationCreateNestedOneWithoutNavagation_planInput
    MoveStaus: move_statusCreateNestedOneWithoutNavagation_planInput
    User: usersCreateNestedOneWithoutNavagation_planInput
  }

  export type navagation_planUncheckedCreateWithoutMovimentationInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_user: number
    cd_company: number
    cd_move_status: number
    id_nav_plan?: number
  }

  export type navagation_planCreateOrConnectWithoutMovimentationInput = {
    where: navagation_planWhereUniqueInput
    create: XOR<navagation_planCreateWithoutMovimentationInput, navagation_planUncheckedCreateWithoutMovimentationInput>
  }

  export type companyUpsertWithoutMovimentationInput = {
    update: XOR<companyUpdateWithoutMovimentationInput, companyUncheckedUpdateWithoutMovimentationInput>
    create: XOR<companyCreateWithoutMovimentationInput, companyUncheckedCreateWithoutMovimentationInput>
  }

  export type companyUpdateWithoutMovimentationInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateManyWithoutCompanyInput
    location?: locationUpdateManyWithoutCompanyInput
    mariner?: marinerUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUpdateManyWithoutCompanyInput
    ship?: shipUpdateManyWithoutCompanyInput
    users?: usersUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateWithoutMovimentationInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUncheckedUpdateManyWithoutCompanyInput
    location?: locationUncheckedUpdateManyWithoutCompanyInput
    mariner?: marinerUncheckedUpdateManyWithoutCompanyInput
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutCompanyInput
    ship?: shipUncheckedUpdateManyWithoutCompanyInput
    users?: usersUncheckedUpdateManyWithoutCompanyInput
  }

  export type move_statusUpsertWithoutMovimentationInput = {
    update: XOR<move_statusUpdateWithoutMovimentationInput, move_statusUncheckedUpdateWithoutMovimentationInput>
    create: XOR<move_statusCreateWithoutMovimentationInput, move_statusUncheckedCreateWithoutMovimentationInput>
  }

  export type move_statusUpdateWithoutMovimentationInput = {
    ds_status?: StringFieldUpdateOperationsInput | string
    navagation_plan?: navagation_planUpdateManyWithoutMoveStausInput
  }

  export type move_statusUncheckedUpdateWithoutMovimentationInput = {
    id_status?: IntFieldUpdateOperationsInput | number
    ds_status?: StringFieldUpdateOperationsInput | string
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutMoveStausInput
  }

  export type navagation_planUpsertWithoutMovimentationInput = {
    update: XOR<navagation_planUpdateWithoutMovimentationInput, navagation_planUncheckedUpdateWithoutMovimentationInput>
    create: XOR<navagation_planCreateWithoutMovimentationInput, navagation_planUncheckedCreateWithoutMovimentationInput>
  }

  export type navagation_planUpdateWithoutMovimentationInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    Company?: companyUpdateOneRequiredWithoutNavagation_planInput
    Location?: locationUpdateOneRequiredWithoutNavagation_planInput
    MoveStaus?: move_statusUpdateOneRequiredWithoutNavagation_planInput
    User?: usersUpdateOneRequiredWithoutNavagation_planInput
  }

  export type navagation_planUncheckedUpdateWithoutMovimentationInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_destiny?: IntFieldUpdateOperationsInput | number
    cd_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    cd_move_status?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
  }

  export type companyCreateWithoutNavagation_planInput = {
    ds_cnpj: string
    ds_name: string
    client?: clientCreateNestedManyWithoutCompanyInput
    location?: locationCreateNestedManyWithoutCompanyInput
    mariner?: marinerCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationCreateNestedManyWithoutCompanyInput
    ship?: shipCreateNestedManyWithoutCompanyInput
    users?: usersCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutNavagation_planInput = {
    id_company?: number
    ds_cnpj: string
    ds_name: string
    client?: clientUncheckedCreateNestedManyWithoutCompanyInput
    location?: locationUncheckedCreateNestedManyWithoutCompanyInput
    mariner?: marinerUncheckedCreateNestedManyWithoutCompanyInput
    movimentation?: movimentationUncheckedCreateNestedManyWithoutCompanyInput
    ship?: shipUncheckedCreateNestedManyWithoutCompanyInput
    users?: usersUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutNavagation_planInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutNavagation_planInput, companyUncheckedCreateWithoutNavagation_planInput>
  }

  export type locationCreateWithoutNavagation_planInput = {
    ds_location: string
    Company: companyCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutNavagation_planInput = {
    id_location?: number
    ds_location: string
    cd_company: number
  }

  export type locationCreateOrConnectWithoutNavagation_planInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutNavagation_planInput, locationUncheckedCreateWithoutNavagation_planInput>
  }

  export type move_statusCreateWithoutNavagation_planInput = {
    ds_status: string
    movimentation?: movimentationCreateNestedManyWithoutMove_stausInput
  }

  export type move_statusUncheckedCreateWithoutNavagation_planInput = {
    id_status?: number
    ds_status: string
    movimentation?: movimentationUncheckedCreateNestedManyWithoutMove_stausInput
  }

  export type move_statusCreateOrConnectWithoutNavagation_planInput = {
    where: move_statusWhereUniqueInput
    create: XOR<move_statusCreateWithoutNavagation_planInput, move_statusUncheckedCreateWithoutNavagation_planInput>
  }

  export type usersCreateWithoutNavagation_planInput = {
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
    Company: companyCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNavagation_planInput = {
    id_user?: number
    cd_company: number
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
  }

  export type usersCreateOrConnectWithoutNavagation_planInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNavagation_planInput, usersUncheckedCreateWithoutNavagation_planInput>
  }

  export type movimentationCreateWithoutNavagation_planInput = {
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    Company: companyCreateNestedOneWithoutMovimentationInput
    move_staus: move_statusCreateNestedOneWithoutMovimentationInput
  }

  export type movimentationUncheckedCreateWithoutNavagation_planInput = {
    id_movimentation?: number
    cd_company: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_move_status: number
  }

  export type movimentationCreateOrConnectWithoutNavagation_planInput = {
    where: movimentationWhereUniqueInput
    create: XOR<movimentationCreateWithoutNavagation_planInput, movimentationUncheckedCreateWithoutNavagation_planInput>
  }

  export type movimentationCreateManyNavagation_planInputEnvelope = {
    data: Enumerable<movimentationCreateManyNavagation_planInput>
    skipDuplicates?: boolean
  }

  export type companyUpsertWithoutNavagation_planInput = {
    update: XOR<companyUpdateWithoutNavagation_planInput, companyUncheckedUpdateWithoutNavagation_planInput>
    create: XOR<companyCreateWithoutNavagation_planInput, companyUncheckedCreateWithoutNavagation_planInput>
  }

  export type companyUpdateWithoutNavagation_planInput = {
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateManyWithoutCompanyInput
    location?: locationUpdateManyWithoutCompanyInput
    mariner?: marinerUpdateManyWithoutCompanyInput
    movimentation?: movimentationUpdateManyWithoutCompanyInput
    ship?: shipUpdateManyWithoutCompanyInput
    users?: usersUpdateManyWithoutCompanyInput
  }

  export type companyUncheckedUpdateWithoutNavagation_planInput = {
    id_company?: IntFieldUpdateOperationsInput | number
    ds_cnpj?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    client?: clientUncheckedUpdateManyWithoutCompanyInput
    location?: locationUncheckedUpdateManyWithoutCompanyInput
    mariner?: marinerUncheckedUpdateManyWithoutCompanyInput
    movimentation?: movimentationUncheckedUpdateManyWithoutCompanyInput
    ship?: shipUncheckedUpdateManyWithoutCompanyInput
    users?: usersUncheckedUpdateManyWithoutCompanyInput
  }

  export type locationUpsertWithoutNavagation_planInput = {
    update: XOR<locationUpdateWithoutNavagation_planInput, locationUncheckedUpdateWithoutNavagation_planInput>
    create: XOR<locationCreateWithoutNavagation_planInput, locationUncheckedCreateWithoutNavagation_planInput>
  }

  export type locationUpdateWithoutNavagation_planInput = {
    ds_location?: StringFieldUpdateOperationsInput | string
    Company?: companyUpdateOneRequiredWithoutLocationInput
  }

  export type locationUncheckedUpdateWithoutNavagation_planInput = {
    id_location?: IntFieldUpdateOperationsInput | number
    ds_location?: StringFieldUpdateOperationsInput | string
    cd_company?: IntFieldUpdateOperationsInput | number
  }

  export type move_statusUpsertWithoutNavagation_planInput = {
    update: XOR<move_statusUpdateWithoutNavagation_planInput, move_statusUncheckedUpdateWithoutNavagation_planInput>
    create: XOR<move_statusCreateWithoutNavagation_planInput, move_statusUncheckedCreateWithoutNavagation_planInput>
  }

  export type move_statusUpdateWithoutNavagation_planInput = {
    ds_status?: StringFieldUpdateOperationsInput | string
    movimentation?: movimentationUpdateManyWithoutMove_stausInput
  }

  export type move_statusUncheckedUpdateWithoutNavagation_planInput = {
    id_status?: IntFieldUpdateOperationsInput | number
    ds_status?: StringFieldUpdateOperationsInput | string
    movimentation?: movimentationUncheckedUpdateManyWithoutMove_stausInput
  }

  export type usersUpsertWithoutNavagation_planInput = {
    update: XOR<usersUpdateWithoutNavagation_planInput, usersUncheckedUpdateWithoutNavagation_planInput>
    create: XOR<usersCreateWithoutNavagation_planInput, usersUncheckedCreateWithoutNavagation_planInput>
  }

  export type usersUpdateWithoutNavagation_planInput = {
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
    Company?: companyUpdateOneRequiredWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutNavagation_planInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type movimentationUpsertWithWhereUniqueWithoutNavagation_planInput = {
    where: movimentationWhereUniqueInput
    update: XOR<movimentationUpdateWithoutNavagation_planInput, movimentationUncheckedUpdateWithoutNavagation_planInput>
    create: XOR<movimentationCreateWithoutNavagation_planInput, movimentationUncheckedCreateWithoutNavagation_planInput>
  }

  export type movimentationUpdateWithWhereUniqueWithoutNavagation_planInput = {
    where: movimentationWhereUniqueInput
    data: XOR<movimentationUpdateWithoutNavagation_planInput, movimentationUncheckedUpdateWithoutNavagation_planInput>
  }

  export type movimentationUpdateManyWithWhereWithoutNavagation_planInput = {
    where: movimentationScalarWhereInput
    data: XOR<movimentationUpdateManyMutationInput, movimentationUncheckedUpdateManyWithoutMovimentationInput>
  }

  export type navagation_planCreateManyUserInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_company: number
    cd_move_status: number
    id_nav_plan?: number
  }

  export type navagation_planUpdateWithoutUserInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    Company?: companyUpdateOneRequiredWithoutNavagation_planInput
    Location?: locationUpdateOneRequiredWithoutNavagation_planInput
    MoveStaus?: move_statusUpdateOneRequiredWithoutNavagation_planInput
    movimentation?: movimentationUpdateManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedUpdateWithoutUserInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_destiny?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    cd_move_status?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
    movimentation?: movimentationUncheckedUpdateManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedUpdateManyWithoutNavagation_planInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_destiny?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    cd_move_status?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
  }

  export type clientCreateManyCompanyInput = {
    id_client?: number
    ds_name: string
    ds_cpf: string
  }

  export type locationCreateManyCompanyInput = {
    id_location?: number
    ds_location: string
  }

  export type marinerCreateManyCompanyInput = {
    id_mariner?: number
    ds_name: string
    ds_cpf: string
  }

  export type movimentationCreateManyCompanyInput = {
    id_movimentation?: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_move_status: number
    cd_nav_plan?: number | null
  }

  export type navagation_planCreateManyCompanyInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_user: number
    cd_move_status: number
    id_nav_plan?: number
  }

  export type shipCreateManyCompanyInput = {
    id_ship?: number
    ds_ship: string
  }

  export type usersCreateManyCompanyInput = {
    id_user?: number
    ds_email: string
    ds_name: string
    ds_password: string
    id_manager?: boolean
    id_operational?: boolean
    id_operator?: boolean
  }

  export type clientUpdateWithoutCompanyInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    ship_client?: ship_clientUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateWithoutCompanyInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    ship_client?: ship_clientUncheckedUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateManyWithoutClientInput = {
    id_client?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
  }

  export type locationUpdateWithoutCompanyInput = {
    ds_location?: StringFieldUpdateOperationsInput | string
    navagation_plan?: navagation_planUpdateManyWithoutLocationInput
  }

  export type locationUncheckedUpdateWithoutCompanyInput = {
    id_location?: IntFieldUpdateOperationsInput | number
    ds_location?: StringFieldUpdateOperationsInput | string
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutLocationInput
  }

  export type locationUncheckedUpdateManyWithoutLocationInput = {
    id_location?: IntFieldUpdateOperationsInput | number
    ds_location?: StringFieldUpdateOperationsInput | string
  }

  export type marinerUpdateWithoutCompanyInput = {
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    ship_mariner?: ship_marinerUpdateManyWithoutMarinerInput
  }

  export type marinerUncheckedUpdateWithoutCompanyInput = {
    id_mariner?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
    ship_mariner?: ship_marinerUncheckedUpdateManyWithoutMarinerInput
  }

  export type marinerUncheckedUpdateManyWithoutMarinerInput = {
    id_mariner?: IntFieldUpdateOperationsInput | number
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_cpf?: StringFieldUpdateOperationsInput | string
  }

  export type movimentationUpdateWithoutCompanyInput = {
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    move_staus?: move_statusUpdateOneRequiredWithoutMovimentationInput
    navagation_plan?: navagation_planUpdateOneWithoutMovimentationInput
  }

  export type movimentationUncheckedUpdateWithoutCompanyInput = {
    id_movimentation?: IntFieldUpdateOperationsInput | number
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    cd_move_status?: IntFieldUpdateOperationsInput | number
    cd_nav_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type movimentationUncheckedUpdateManyWithoutMovimentationInput = {
    id_movimentation?: IntFieldUpdateOperationsInput | number
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    cd_move_status?: IntFieldUpdateOperationsInput | number
    cd_nav_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type navagation_planUpdateWithoutCompanyInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: locationUpdateOneRequiredWithoutNavagation_planInput
    MoveStaus?: move_statusUpdateOneRequiredWithoutNavagation_planInput
    User?: usersUpdateOneRequiredWithoutNavagation_planInput
    movimentation?: movimentationUpdateManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedUpdateWithoutCompanyInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_destiny?: IntFieldUpdateOperationsInput | number
    cd_user?: IntFieldUpdateOperationsInput | number
    cd_move_status?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
    movimentation?: movimentationUncheckedUpdateManyWithoutNavagation_planInput
  }

  export type shipUpdateWithoutCompanyInput = {
    ds_ship?: StringFieldUpdateOperationsInput | string
    ship_client?: ship_clientUpdateManyWithoutShipInput
    ship_mariner?: ship_marinerUpdateManyWithoutShipInput
  }

  export type shipUncheckedUpdateWithoutCompanyInput = {
    id_ship?: IntFieldUpdateOperationsInput | number
    ds_ship?: StringFieldUpdateOperationsInput | string
    ship_client?: ship_clientUncheckedUpdateManyWithoutShipInput
    ship_mariner?: ship_marinerUncheckedUpdateManyWithoutShipInput
  }

  export type shipUncheckedUpdateManyWithoutShipInput = {
    id_ship?: IntFieldUpdateOperationsInput | number
    ds_ship?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpdateWithoutCompanyInput = {
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
    navagation_plan?: navagation_planUpdateManyWithoutUserInput
  }

  export type usersUncheckedUpdateWithoutCompanyInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
    navagation_plan?: navagation_planUncheckedUpdateManyWithoutUserInput
  }

  export type usersUncheckedUpdateManyWithoutUsersInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    ds_email?: StringFieldUpdateOperationsInput | string
    ds_name?: StringFieldUpdateOperationsInput | string
    ds_password?: StringFieldUpdateOperationsInput | string
    id_manager?: BoolFieldUpdateOperationsInput | boolean
    id_operational?: BoolFieldUpdateOperationsInput | boolean
    id_operator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type navagation_planCreateManyLocationInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_user: number
    cd_company: number
    cd_move_status: number
    id_nav_plan?: number
  }

  export type navagation_planUpdateWithoutLocationInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    Company?: companyUpdateOneRequiredWithoutNavagation_planInput
    MoveStaus?: move_statusUpdateOneRequiredWithoutNavagation_planInput
    User?: usersUpdateOneRequiredWithoutNavagation_planInput
    movimentation?: movimentationUpdateManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedUpdateWithoutLocationInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    cd_move_status?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
    movimentation?: movimentationUncheckedUpdateManyWithoutNavagation_planInput
  }

  export type movimentationCreateManyMove_stausInput = {
    id_movimentation?: number
    cd_company: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_nav_plan?: number | null
  }

  export type navagation_planCreateManyMoveStausInput = {
    qt_crew: number
    qt_passengers: number
    dt_departure: Date | string
    dt_arrival?: Date | string | null
    ds_observation?: string | null
    cd_destiny: number
    cd_user: number
    cd_company: number
    id_nav_plan?: number
  }

  export type movimentationUpdateWithoutMove_stausInput = {
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    Company?: companyUpdateOneRequiredWithoutMovimentationInput
    navagation_plan?: navagation_planUpdateOneWithoutMovimentationInput
  }

  export type movimentationUncheckedUpdateWithoutMove_stausInput = {
    id_movimentation?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    cd_nav_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type navagation_planUpdateWithoutMoveStausInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    Company?: companyUpdateOneRequiredWithoutNavagation_planInput
    Location?: locationUpdateOneRequiredWithoutNavagation_planInput
    User?: usersUpdateOneRequiredWithoutNavagation_planInput
    movimentation?: movimentationUpdateManyWithoutNavagation_planInput
  }

  export type navagation_planUncheckedUpdateWithoutMoveStausInput = {
    qt_crew?: IntFieldUpdateOperationsInput | number
    qt_passengers?: IntFieldUpdateOperationsInput | number
    dt_departure?: DateTimeFieldUpdateOperationsInput | Date | string
    dt_arrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ds_observation?: NullableStringFieldUpdateOperationsInput | string | null
    cd_destiny?: IntFieldUpdateOperationsInput | number
    cd_user?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    id_nav_plan?: IntFieldUpdateOperationsInput | number
    movimentation?: movimentationUncheckedUpdateManyWithoutNavagation_planInput
  }

  export type ship_clientCreateManyClientInput = {
    cd_ship: number
    id_cliente_mariner?: number
  }

  export type ship_clientUpdateWithoutClientInput = {
    Ship?: shipUpdateOneRequiredWithoutShip_clientInput
  }

  export type ship_clientUncheckedUpdateWithoutClientInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_clientUncheckedUpdateManyWithoutShip_clientInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_marinerCreateManyMarinerInput = {
    cd_ship: number
    id_cliente_mariner?: number
  }

  export type ship_marinerUpdateWithoutMarinerInput = {
    Ship?: shipUpdateOneRequiredWithoutShip_marinerInput
  }

  export type ship_marinerUncheckedUpdateWithoutMarinerInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_marinerUncheckedUpdateManyWithoutShip_marinerInput = {
    cd_ship?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_clientCreateManyShipInput = {
    cd_client: number
    id_cliente_mariner?: number
  }

  export type ship_marinerCreateManyShipInput = {
    cd_mariner: number
    id_cliente_mariner?: number
  }

  export type ship_clientUpdateWithoutShipInput = {
    Client?: clientUpdateOneRequiredWithoutShip_clientInput
  }

  export type ship_clientUncheckedUpdateWithoutShipInput = {
    cd_client?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type ship_marinerUpdateWithoutShipInput = {
    Mariner?: marinerUpdateOneRequiredWithoutShip_marinerInput
  }

  export type ship_marinerUncheckedUpdateWithoutShipInput = {
    cd_mariner?: IntFieldUpdateOperationsInput | number
    id_cliente_mariner?: IntFieldUpdateOperationsInput | number
  }

  export type movimentationCreateManyNavagation_planInput = {
    id_movimentation?: number
    cd_company: number
    dt_finished?: Date | string | null
    dt_opned?: Date | string
    id_finished?: boolean
    cd_move_status: number
  }

  export type movimentationUpdateWithoutNavagation_planInput = {
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    Company?: companyUpdateOneRequiredWithoutMovimentationInput
    move_staus?: move_statusUpdateOneRequiredWithoutMovimentationInput
  }

  export type movimentationUncheckedUpdateWithoutNavagation_planInput = {
    id_movimentation?: IntFieldUpdateOperationsInput | number
    cd_company?: IntFieldUpdateOperationsInput | number
    dt_finished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dt_opned?: DateTimeFieldUpdateOperationsInput | Date | string
    id_finished?: BoolFieldUpdateOperationsInput | boolean
    cd_move_status?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}